{"version":3,"sources":["../src/index.ts","../src/DLNode.ts","../src/HTMLNode.ts","../src/CompNode.ts","../src/MutableNode/MutableNode.ts","../src/MutableNode/ForNode.ts","../src/MutableNode/ExpNode.ts","../src/MutableNode/CondNode.ts","../src/EnvNode.ts","../src/TextNode.ts","../src/PropView.ts"],"sourcesContent":["import { type AnyDLNode } from \"./DLNode\"\nimport { insertNode } from \"./HTMLNode\"\n\nexport * from \"./HTMLNode\"\nexport * from \"./CompNode\"\nexport * from \"./MutableNode/ForNode\"\nexport * from \"./MutableNode/ExpNode\"\nexport * from \"./MutableNode/CondNode\"\nexport * from \"./EnvNode\"\nexport * from \"./TextNode\"\nexport * from \"./PropView\"\n\nexport function render(idOrEl: string | HTMLElement, DL: AnyDLNode) {\n  let el: HTMLElement = idOrEl as HTMLElement\n  if (typeof idOrEl === \"string\") {\n    const elFound = document.getElementById(idOrEl)\n    if (elFound) el = elFound\n    else {\n      throw new Error(`DLight: Element with id ${idOrEl} not found`)\n    }\n  }\n  el.innerHTML = \"\"\n  const dlNode = new DL()\n  insertNode(el, dlNode, 0)\n}\n\nexport function manual(callback: () => any, _deps?: any[]) {\n  return callback()\n}\nexport function escape<T>(arg: T): T {\n  return arg\n}\n\nexport const $ = escape\n","export type AnyDLNode = any\n\nexport enum DLNodeType {\n  Comp = 0,\n  For,\n  Cond,\n  Env,\n  Exp,\n  Subview,\n}\n\nexport class DLNode {\n  /**\n   * @brief Node type: HTML, Text, Custom, For, If, Env, Expression\n   */\n  _$dlNodeType: DLNodeType\n\n  /**\n   * @brief Constructor\n   * @param nodeType\n   */\n  constructor(nodeType: DLNodeType) {\n    this._$dlNodeType = nodeType\n  }\n\n  /**\n   * @brief Node element\n   *  Either one real element for HTMLNode and TextNode\n   *  Or an array of DLNode for CustomNode, ForNode, IfNode, EnvNode, ExpNode\n   */\n  get _$el(): HTMLElement[] {\n    return DLNode.toEls(this._$nodes!)\n  }\n\n  /**\n   * @brief Parent dom element, will be passed to child nodes\n   */\n  _$parentEl?: HTMLElement\n\n  /**\n   * @brief Child DLNodes\n   */\n  _$nodes?: AnyDLNode[]\n\n  /**\n   * @brief Loop all child DLNodes to get all the child elements\n   * @param nodes\n   * @returns HTMLElement[]\n   */\n  private static toEls(nodes: DLNode[]): HTMLElement[] {\n    const els: HTMLElement[] = []\n    this.loopShallowEls(nodes, el => {\n      els.push(el)\n    })\n    return els\n  }\n\n  // ---- Loop nodes ----\n  /**\n   * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopDLNodes(nodes: AnyDLNode[], runFunc: (node: AnyDLNode) => void) {\n    nodes.forEach(node => {\n      runFunc(node)\n      node._$nodes && DLNode.loopDLNodes(node._$nodes, runFunc)\n    })\n  }\n\n  /**\n   * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopDLNodesInsideOut(\n    nodes: AnyDLNode[],\n    runFunc: (node: AnyDLNode) => void\n  ) {\n    nodes.forEach(node => {\n      node._$nodes && DLNode.loopDLNodesInsideOut(node._$nodes, runFunc)\n      runFunc(node)\n    })\n  }\n\n  /**\n   * @brief Loop all elements shallowly,\n   *  i.e., don't loop the child nodes of dom elements and only call runFunc on dom elements\n   * @param nodes\n   * @param runFunc\n   */\n  static loopShallowEls(\n    nodes: AnyDLNode[],\n    runFunc: (node: AnyDLNode) => void\n  ) {\n    nodes.forEach(node => {\n      if (!(\"_$dlNodeType\" in node)) return runFunc(node)\n      node._$nodes && DLNode.loopShallowEls(node._$nodes, runFunc)\n    })\n  }\n\n  /**\n   * @brief Loop all nodes shallowly,\n   *  i.e., don't loop the child nodes of dom elements and call runFunc on all nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopShallowDLNodes(nodes: any[], runFunc: (node: any) => void): void {\n    nodes.forEach(node => {\n      if (\"_$dlNodeType\" in node) {\n        runFunc(node)\n        node._$nodes && DLNode.loopShallowDLNodes(node._$nodes, runFunc)\n      }\n    })\n  }\n\n  /**\n   * @brief Add parentEl to all nodes until the first element\n   * @param nodes\n   * @param parentEl\n   */\n  static addParentEl(nodes: AnyDLNode[], parentEl: HTMLElement): void {\n    this.loopShallowDLNodes(nodes, node => {\n      node._$parentEl = parentEl\n    })\n  }\n\n  // ---- Flow index and add child elements ----\n  /**\n   * @brief Get the total count of dom elements before the stop node\n   * @param nodes\n   * @param stopNode\n   * @returns total count of dom elements\n   */\n  static getFlowIndexFromNodes(\n    nodes: AnyDLNode[],\n    stopNode?: AnyDLNode\n  ): number {\n    let index = 0\n    const stack = [...nodes]\n    while (stack.length > 0) {\n      const node = stack.shift()!\n      if (node === stopNode) break\n      if (\"_$dlNodeType\" in node) {\n        node._$nodes && stack.unshift(...node._$nodes)\n      } else {\n        index++\n      }\n    }\n    return index\n  }\n\n  /**\n   * @brief Given an array of nodes, append them to the parentEl\n   *  1. If nextSibling is provided, insert the nodes before the nextSibling\n   *  2. If nextSibling is not provided, append the nodes to the parentEl\n   * @param nodes\n   * @param parentEl\n   * @param nextSibling\n   * @returns Added element count\n   */\n  static appendNodesWithSibling(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    nextSibling: HTMLElement | undefined\n  ): number {\n    if (nextSibling) return this.insertNodesBefore(nodes, parentEl, nextSibling)\n    return this.appendNodes(nodes, parentEl)\n  }\n\n  /**\n   * @brief Given an array of nodes, append them to the parentEl using the index\n   *  1. If the index is the same as the length of the parentEl.childNodes, append the nodes to the parentEl\n   *  2. If the index is not the same as the length of the parentEl.childNodes, insert the nodes before the node at the index\n   * @param nodes\n   * @param parentEl\n   * @param index\n   * @param length\n   * @returns Added element count\n   */\n  static appendNodesWithIndex(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    index: number,\n    length?: number\n  ): number {\n    length = length ?? parentEl.childNodes.length\n    if (length !== index)\n      return this.insertNodesBefore(\n        nodes,\n        parentEl,\n        parentEl.childNodes[index] as any\n      )\n    return this.appendNodes(nodes, parentEl)\n  }\n\n  /**\n   * @brief Insert nodes before the nextSibling\n   * @param nodes\n   * @param parentEl\n   * @param nextSibling\n   * @returns Added element count\n   */\n  static insertNodesBefore(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    nextSibling: HTMLElement\n  ): number {\n    let count = 0\n    this.loopShallowEls(nodes, el => {\n      parentEl.insertBefore(el, nextSibling)\n      count++\n    })\n    return count\n  }\n\n  /**\n   * @brief Append nodes to the parentEl\n   * @param nodes\n   * @param parentEl\n   * @returns Added element count\n   */\n  static appendNodes(nodes: any[], parentEl: HTMLElement): number {\n    let count = 0\n    this.loopShallowEls(nodes, el => {\n      parentEl.appendChild(el)\n      count++\n    })\n    return count\n  }\n\n  private static willUnmountFunc(currFunc: () => void, prevFunc?: () => void) {\n    currFunc()\n    prevFunc?.()\n  }\n\n  // ---- Lifecycle ----\n  static addWillUnmount(node: AnyDLNode, func: () => void) {\n    node.willUnmount = this.willUnmountFunc.bind(this, func, node.willUnmount)\n  }\n}\n","import { DLNode, type AnyDLNode } from \"./DLNode\"\n\n/**\n * @brief Plainly set style\n * @param el\n * @param value\n */\nexport function setStyle(el: HTMLElement, value: CSSStyleDeclaration): void {\n  Object.entries(value).forEach(([key, value]) => {\n    el.style[key as any] = value\n  })\n}\n\n/**\n * @brief Plainly set dataset\n * @param el\n * @param value\n */\nexport function setDataset(\n  el: HTMLElement,\n  value: Record<string, string>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    el.dataset[key] = value\n  })\n}\n\n/**\n * @brief Set HTML property with checking value equality first\n * @param el\n * @param key\n * @param value\n */\nexport function setHTMLProp(\n  el: HTMLElement,\n  key: keyof HTMLElement,\n  value: any\n): void {\n  const prevKey = `$${key}`\n  if (prevKey in el && (el as AnyDLNode)[prevKey] === value) return\n  ;(el as AnyDLNode)[key] = value\n  ;(el as AnyDLNode)[prevKey] = value\n}\n\n/**\n * @brief Plainly set HTML properties\n * @param el\n * @param value\n */\nexport function setHTMLProps(\n  el: HTMLElement,\n  value: Record<string, any>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    setHTMLProp(el, key as any, value)\n  })\n}\n\n/**\n * @brief Set HTML attribute with checking value equality first\n * @param el\n * @param key\n * @param value\n */\nexport function setHTMLAttr(el: HTMLElement, key: string, value: any): void {\n  const prevKey = `$${key}`\n  if (prevKey in el && (el as AnyDLNode)[prevKey] === value) return\n  el.setAttribute(key, value)\n  ;(el as AnyDLNode)[prevKey] = value\n}\n\n/**\n * @brief Plainly set HTML attributes\n * @param el\n * @param value\n */\nexport function setHTMLAttrs(\n  el: HTMLElement,\n  value: Record<string, any>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    setHTMLAttr(el, key, value)\n  })\n}\n\n/**\n * @brief Set memorized event, store the previous event in el[`$on${key}`], if it exists, remove it first\n * @param el\n * @param key\n * @param value\n */\nexport function setEvent(el: HTMLElement, key: string, value: any): void {\n  const prevEvent = (el as any)[`$on${key}`]\n  if (prevEvent) el.removeEventListener(key, prevEvent)\n  el.addEventListener(key, value)\n  ;(el as any)[`$on${key}`] = value\n}\n\n/**\n * @brief Create a template function, which returns a function that returns a cloned element\n * @param templateStr\n * @returns a function that returns a cloned element\n */\nexport function createTemplate(templateStr: string): () => HTMLElement {\n  const template = document.createElement(\"template\")\n  template.innerHTML = templateStr\n\n  const element = template.content.firstChild\n  return () => element!.cloneNode(true) as HTMLElement\n}\n\n/**\n * @brief Shortcut for document.createElement\n * @param tag\n * @returns HTMLElement\n */\nexport function createElement(tag: string): HTMLElement {\n  return document.createElement(tag)\n}\n\n/**\n * @brief Insert any DLNode into an element, set the _$nodes and append the element to the element's children\n * @param el\n * @param node\n * @param position\n */\nexport function insertNode(\n  el: HTMLElement,\n  node: AnyDLNode,\n  position: number\n): void {\n  // ---- Set _$nodes\n  if (!(el as AnyDLNode)._$nodes)\n    (el as AnyDLNode)._$nodes = Array.from(el.childNodes)\n  ;(el as AnyDLNode)._$nodes.splice(position, 0, node)\n\n  // ---- Insert nodes' elements\n  DLNode.appendNodesWithIndex([node], el, position)\n  // ---- Set parentEl\n  DLNode.addParentEl([node], el)\n}\n\n/**\n * @brief An inclusive assign prop function that accepts any type of prop\n * @param el\n * @param key\n * @param value\n */\nexport function forwardHTMLProp(\n  el: HTMLElement,\n  key: string,\n  value: any\n): void {\n  if (key === \"style\") {\n    setStyle(el, value)\n    return\n  }\n  if (key === \"dataset\") {\n    setDataset(el, value)\n    return\n  }\n  if (key === \"element\") return\n  if (key === \"prop\") {\n    setHTMLProps(el, value)\n    return\n  }\n  if (key === \"attr\") {\n    setHTMLAttrs(el, value)\n    return\n  }\n  if (key === \"innerHTML\") {\n    setHTMLProp(el, \"innerHTML\", value)\n    return\n  }\n  if (key === \"forwardProp\") return\n  if (key.startsWith(\"on\")) {\n    setEvent(el, key.slice(2).toLowerCase(), value)\n    return\n  }\n  setHTMLAttr(el, key, value)\n}\n","import { type AnyDLNode, DLNode, DLNodeType } from \"./DLNode\"\nimport { type EnvNode } from \"./EnvNode\"\nimport { forwardHTMLProp } from \"./HTMLNode\"\n\nexport class CompNode extends DLNode {\n  /**\n   * @brief Constructor, Comp type\n   * @internal\n   *  * key - getter: return $key\n   *  * key - setter: set $key, update $s$key, call update function with $$key\n   *  * $key - private property key\n   *  * $$key - dependency number, e.g. 0b1, 0b10, 0b100\n   *  * $s$key - set of properties that depend on this property\n   *  * $p$key - exist if this property is a prop\n   *  * $e$key - exist if this property is an env\n   *  * $en$key - exist if this property is an env, and it's the innermost env that contains this env\n   *  * $w$key - exist if this property is a watcher\n   *  * $f$key - a function that returns the value of this property, called when the property's dependencies change\n   *  * _$children - children nodes of type PropView\n   *  * _$contentKey - the key key of the content prop\n   *  * _$forwardProps - exist if this node is forwarding props\n   *  * _$forwardPropsId - the keys of the props that this node is forwarding, collected in _$setForwardProp\n   *  * _$forwardPropsSet - contain all the nodes that are forwarding props to this node, collected with _$addForwardProps\n   */\n  constructor() {\n    super(DLNodeType.Comp)\n  }\n\n  /**\n   * @brief Init function, called explicitly in the subclass's constructor\n   * @param props\n   * @param content\n   * @param children\n   * @param forwardPropsScope\n   */\n  _$init(\n    props: Record<string, any> | null,\n    content: any | null,\n    children: AnyDLNode[] | null,\n    forwardPropsScope: CompNode | null\n  ): void {\n    // ---- Add props\n    // ---- Forward props first to allow internal props to override forwarded props\n    if (forwardPropsScope) forwardPropsScope._$addForwardProps(this)\n    if (content !== null) this._$setContent(content)\n    if (props) {\n      Object.entries(props).forEach(([key, value]) => {\n        this._$setProp(key, value)\n      })\n    }\n    if (children) (this as AnyDLNode)._$children = children\n\n    // ---- Add envs\n    Object.entries(window.DLEnvStore.envs).forEach(\n      ([key, [value, envNode]]) => {\n        // ---- Add this node to every envNode's updateNodes\n        envNode.addNode(this)\n        this._$initEnv(key, value, envNode)\n      }\n    )\n\n    // ---- Call watchers\n    this._$callUpdatesBeforeInit()\n    // ---- init\n    ;(this as AnyDLNode).willMount?.()\n    this._$nodes = (this as AnyDLNode).View?.() ?? []\n    ;(this as AnyDLNode).didMount?.()\n  }\n\n  /**\n   * @brief Call updates manually before the node is mounted\n   */\n  private _$callUpdatesBeforeInit(): void {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n    const ownProps = Object.getOwnPropertyNames(this)\n    const allProps = [...protoProps, ...ownProps]\n    allProps.forEach(key => {\n      if (key.startsWith(\"$w$\")) return (this as any)[key.slice(3)]()\n      if (key.startsWith(\"$f$\")) {\n        ;(this as any)[`$${key.slice(3)}`] = (this as any)[key]\n      }\n    })\n  }\n\n  /**\n   * @brief Define forward props\n   * @param key\n   * @param value\n   */\n  private _$setForwardProp(key: string, value: any): void {\n    // ---- If the prop is already defined, don't forward it\n    if (key in this) {\n      ;(this as AnyDLNode)[key] = value\n      return\n    }\n    ;(this as AnyDLNode)._$forwardPropsId.push(key)\n    const valueKey = `$${key}`\n    ;(this as AnyDLNode)[valueKey] = value\n    Object.defineProperty(this, key, {\n      get() {\n        return this[valueKey]\n      },\n      set(value) {\n        if (this[valueKey] === value) return\n        this[valueKey] = value\n        // ---- Don't need to call update function because the prop is not a explicit dependency\n        ;(this as AnyDLNode)._$forwardPropsSet?.forEach((node: AnyDLNode) => {\n          // ---- Directly set the prop if it's a CompNode\n          if (node._$dlNodeType === DLNodeType.Comp) node._$setProp(key, value)\n          // ---- Different behavior for HTMLNode according to the key\n          if (node instanceof HTMLElement) forwardHTMLProp(node, key, value)\n        })\n      },\n    })\n  }\n\n  /**\n   * @brief Add a node to the set of nodes that are forwarding props to this node and init these props, called\n   *  1. HTMLNode: explicitly in the View function\n   *  2. CompNode: passed in the node's constructor and called in _$init to make sure it's added before the node is mounted\n   * @param node\n   */\n  _$addForwardProps(node: AnyDLNode): void {\n    // ---- Add node to the set of nodes that are forwarding props to this node\n    ;(this as AnyDLNode)._$forwardPropsSet.add(node)\n    // ---- Init these forwarded props\n    ;(this as AnyDLNode)._$forwardPropsId.forEach((key: string) => {\n      const value = (this as AnyDLNode)[key]\n      ;(this as AnyDLNode)._$forwardPropsSet?.forEach((node: AnyDLNode) => {\n        // ---- Directly set the prop if it's a CompNode\n        if (node._$dlNodeType === DLNodeType.Comp) {\n          // ---- Pass down forwardProps\n          if (\"_$forwardProps\" in node) node._$forwardPropsId.push(key)\n          node._$setProp(key, value)\n        }\n        // ---- Different behavior for HTMLNode according to the key\n        if (node instanceof HTMLElement) forwardHTMLProp(node, key, value)\n      })\n    })\n    // ---- Remove current node from the set of forwarding nodes when it's unmounted\n    DLNode.addWillUnmount(\n      node,\n      (this as AnyDLNode)._$forwardPropsSet.delete.bind(\n        (this as AnyDLNode)._$forwardPropsSet,\n        node\n      )\n    )\n  }\n\n  /**\n   * @brief Set a prop directly, if this is a forwarded prop, go and init forwarded props\n   * @param key\n   * @param value\n   */\n  _$setProp(key: string, value: any): void {\n    if (\"_$forwardProps\" in this) this._$setForwardProp(key, value)\n    if (!(`$p$${key}` in this)) return\n    ;(this as AnyDLNode)[key] = value\n  }\n\n  /**\n   * @brief Init an env, put the corresponding innermost envNode in $en$key\n   * @param key\n   * @param value\n   * @param envNode\n   */\n  private _$initEnv(key: string, value: any, envNode: EnvNode): void {\n    if (!(`$e$${key}` in this)) return\n    ;(this as AnyDLNode)[key] = value\n    ;(this as AnyDLNode)[`$en$${key}`] = envNode\n  }\n\n  /**\n   * @brief Update an env, called in EnvNode._$update\n   * @param key\n   * @param value\n   * @param envNode\n   */\n  _$updateEnv(key: string, value: any, envNode: EnvNode): void {\n    if (!(`$e$${key}` in this)) return\n    // ---- Make sure the envNode is the innermost envNode that contains this env\n    if (envNode !== (this as AnyDLNode)[`$en$${key}`]) return\n    if ((this as AnyDLNode)[key] === value) return\n    ;(this as AnyDLNode)[key] = value\n  }\n\n  /**\n   * @brief Set the content prop, the key is stored in _$contentKey\n   * @param value\n   * @returns\n   */\n  _$setContent(value: any) {\n    const contentKey = (this as AnyDLNode)._$contentKey\n    if (!contentKey) return\n    if ((this as AnyDLNode)[contentKey] === value) return\n    ;(this as AnyDLNode)[contentKey] = value\n  }\n\n  /**\n   * @brief Update a prop and call any related update function\n   * @param key\n   * @param value\n   */\n  _$updateProp(key: string, value: any): void {\n    const valueKey = `$${key}`\n    if ((this as AnyDLNode)[valueKey] === value) return\n    ;(this as AnyDLNode)[valueKey] = value\n    this._$updateDerived(key)\n    this._$updateView(key)\n  }\n\n  /**\n   * @brief Update properties that depend on this property\n   * @param key\n   */\n  _$updateDerived(key: string): void {\n    // ---- Call update manually before the node is mounted, not here\n    if (!(this as AnyDLNode)._$nodes) return\n    ;(this as AnyDLNode)[`$s$${key}`]?.forEach((k: string) => {\n      // ---- Not time consuming at all\n      if (`$w$${k}` in (this as AnyDLNode)) {\n        ;(this as AnyDLNode)[k]()\n      } else {\n        ;(this as AnyDLNode)[`$${k}`] = (this as AnyDLNode)[`$f$${k}`]\n      }\n    })\n  }\n\n  /**\n   * @brief Update View related update function\n   * @param key\n   */\n  _$updateView(key: string): void {\n    const depNum = (this as AnyDLNode)[`$$${key}`]\n    if (!depNum) return // ---- Run update function\n    ;(this as AnyDLNode)._$update?.(depNum)\n  }\n}\n\n// ---- @View -> class Comp extends View\nexport const View = CompNode as any\n\n/**\n * @brief Run all update functions given the key\n * @param dlNode\n * @param key\n */\nexport function update(dlNode: AnyDLNode, key: string): void {\n  dlNode._$updateDerived(key)\n  dlNode._$updateView(key)\n}\n","import { type AnyDLNode, DLNode } from \"../DLNode\"\n\nexport class MutableNode extends DLNode {\n  /**\n   * @brief Mutable node is a node that this._$nodes can be changed, things need to pay attention:\n   *  1. The environment of the new nodes should be the same as the old nodes\n   *  2. The new nodes should be added to the parentEl\n   *  3. The old nodes should be removed from the parentEl\n   * @param type\n   */\n  constructor(type: number) {\n    super(type)\n    // ---- Save the current environment nodes, must be a new reference\n    if (window.DLEnvStore.currentEnvNodes.length > 0) {\n      ;(this as AnyDLNode).savedEnvNodes = [\n        ...window.DLEnvStore.currentEnvNodes,\n      ]\n    }\n  }\n\n  /**\n   * @brief Initialize the new nodes, add parentEl to all nodes\n   * @param nodes\n   */\n  private initNewNodes(nodes: AnyDLNode[]): void {\n    // ---- Add parentEl to all nodes\n    DLNode.addParentEl(nodes, (this as AnyDLNode)._$parentEl)\n  }\n\n  /**\n   * @brief Generate new nodes in the saved environment\n   * @param newNodesFunc\n   * @returns\n   */\n  geneNewNodesInEnv(newNodesFunc: () => AnyDLNode[]): AnyDLNode[] {\n    if (!(this as AnyDLNode).savedEnvNodes) {\n      // ---- No saved environment, just generate new nodes\n      const newNodes = newNodesFunc()\n      // ---- Only for IfNode's same condition return\n      // ---- Initialize the new nodes\n      this.initNewNodes(newNodes)\n      return newNodes\n    }\n    // ---- Save the current environment nodes\n    const currentEnvNodes = window.DLEnvStore.currentEnvNodes\n    // ---- Replace the saved environment nodes\n    window.DLEnvStore.replaceEnvNodes((this as AnyDLNode).savedEnvNodes)\n    const newNodes = newNodesFunc()\n    // ---- Retrieve the current environment nodes\n    window.DLEnvStore.replaceEnvNodes(currentEnvNodes)\n    // ---- Only for IfNode's same condition return\n    // ---- Initialize the new nodes\n    this.initNewNodes(newNodes)\n    return newNodes\n  }\n\n  removeNodes(nodes: any[]) {\n    DLNode.loopDLNodes(nodes, node => node.willUnmount?.())\n    DLNode.loopShallowEls(nodes, el => {\n      this._$parentEl?.removeChild(el)\n    })\n    DLNode.loopDLNodesInsideOut(nodes, node => node.didUnmount?.())\n  }\n}\n","import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class ForNode<T, G> extends MutableNode {\n  array\n  keys?\n  nodeFunc\n  nodess\n  depNum\n\n  /**\n   * @brief Constructor, For type\n   * @param array\n   * @param nodeFunc\n   * @param keys\n   */\n  constructor(\n    array: T[],\n    nodeFunc: (item: T) => AnyDLNode[],\n    depNum: number,\n    keys?: G[]\n  ) {\n    super(DLNodeType.For)\n    this.array = [...array]\n    this.nodeFunc = nodeFunc\n    this.keys = keys\n    this.depNum = depNum\n\n    this.nodess = this.array.map(item => nodeFunc(item))\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Non-array update function\n   * @param changed\n   */\n  update(changed: number): void {\n    if (changed & this.depNum) return\n    for (let idx = 0; idx < this.array.length; idx++) {\n      this.updateItem(this.nodess[idx], this.array[idx], changed)\n    }\n  }\n\n  /**\n   * @brief Update the view related to one item in the array\n   * @param nodes\n   * @param item\n   */\n  private updateItem(nodes: AnyDLNode[], item: T, changed?: number): void {\n    // ---- The update function of ForNode's childNodes is stored in the first child node\n    nodes[0]._$updateFunc?.(changed ?? this.depNum, item)\n  }\n\n  /**\n   * @brief Array-related update function\n   * @param newArray\n   * @param newKeys\n   */\n  updateArray(newArray: T[], newKeys?: G[]): void {\n    if (newKeys) {\n      this.updateWithKey(newArray, newKeys)\n      return\n    }\n    this.updateWithOutKey(newArray)\n  }\n\n  /**\n   * @brief Shortcut to generate new nodes with idx\n   */\n  private getNewNodes(idx: number) {\n    return this.geneNewNodesInEnv(() => this.nodeFunc(this.array[idx]))\n  }\n\n  /**\n   * @brief Update the nodes without keys\n   * @param newArray\n   */\n  private updateWithOutKey(newArray: T[]): void {\n    const preLength = this.array.length\n    const currLength = newArray.length\n    this.array = [...newArray]\n\n    if (preLength === currLength) {\n      // ---- If the length is the same, we only need to update the nodes\n      for (let idx = 0; idx < this.array.length; idx++) {\n        this.updateItem(this.nodess[idx], this.array[idx])\n      }\n      return\n    }\n\n    const parentEl = (this as AnyDLNode)._$parentEl\n    // ---- If the new array is longer, add new nodes directly\n    if (preLength < currLength) {\n      let flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n      // ---- Calling parentEl.childNodes.length is time-consuming,\n      //      so we use a length variable to store the length\n      const length = parentEl.childNodes.length\n      for (let idx = 0; idx < currLength; idx++) {\n        if (idx < preLength) {\n          flowIndex += MutableNode.getFlowIndexFromNodes(this.nodess[idx])\n          this.updateItem(this.nodess[idx], this.array[idx])\n          continue\n        }\n        const newNodes = this.getNewNodes(idx)\n        MutableNode.appendNodesWithIndex(newNodes, parentEl, flowIndex, length)\n        this.nodess.push(newNodes)\n      }\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    // ---- Update the nodes first\n    for (let idx = 0; idx < currLength; idx++) {\n      this.updateItem(this.nodess[idx], this.array[idx])\n    }\n    // ---- If the new array is shorter, remove the extra nodes\n    for (let idx = currLength; idx < preLength; idx++) {\n      this.removeNodes(this.nodess[idx])\n    }\n    this.nodess = this.nodess.slice(0, currLength)\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Update the nodes with keys\n   * @param newArray\n   * @param newKeys\n   */\n  private updateWithKey(newArray: T[], newKeys: G[]): void {\n    const prevKeys = this.keys!\n    const prevArray = this.array\n\n    this.array = [...newArray]\n    this.keys = newKeys\n\n    if (ForNode.arrayEqual(prevKeys, this.keys)) {\n      // ---- If the keys are the same, we only need to update the nodes\n      for (let idx = 0; idx < this.array.length; idx++) {\n        this.updateItem(this.nodess[idx], this.array[idx])\n      }\n      return\n    }\n\n    const parentEl = (this as AnyDLNode)._$parentEl\n    const prevNodess = this.nodess\n\n    // ---- No nodes after, delete all nodes\n    if (this.keys.length === 0) {\n      const parentNodes = parentEl._$nodes ?? []\n      if (parentNodes.length === 1 && parentNodes[0] === this) {\n        // ---- ForNode is the only node in the parent node\n        //      Frequently used in real life scenarios because we tend to always wrap for with a div element,\n        //      so we optimize it here\n        parentEl.innerHTML = \"\"\n      } else {\n        for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\n          this.removeNodes(prevNodess[prevIdx])\n        }\n      }\n      this.nodess = []\n      this._$nodes = []\n      return\n    }\n\n    // ---- Record how many nodes are before this ForNode with the same parentNode\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n\n    // ---- No nodes before, append all nodes\n    if (prevKeys.length === 0) {\n      const nextSibling = parentEl.childNodes[flowIndex]\n      for (let idx = 0; idx < this.keys.length; idx++) {\n        const newNodes = this.getNewNodes(idx)\n        MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n        this.nodess.push(newNodes)\n      }\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    const shuffleKeys: G[] = []\n    const newNodess = []\n    const arrToUpdate = []\n\n    // ---- 1. Delete the nodes that are no longer in the array\n    for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\n      const prevKey = prevKeys[prevIdx]\n      if (this.keys.includes(prevKey)) {\n        shuffleKeys.push(prevKey)\n        newNodess.push(prevNodess[prevIdx])\n        arrToUpdate.push(prevArray[prevIdx])\n        continue\n      }\n      this.removeNodes(prevNodess[prevIdx])\n    }\n\n    // ---- 2. Add the nodes that are not in the array but in the new array\n    // ---- Calling parentEl.childNodes.length is time-consuming,\n    //      so we use a length variable to store the length\n    let length: number = parentEl.childNodes.length\n    let newFlowIndex = flowIndex\n    for (let idx = 0; idx < this.keys.length; idx++) {\n      const key = this.keys[idx]\n      const prevIdx = shuffleKeys.indexOf(key)\n      if (prevIdx !== -1) {\n        // ---- These nodes are already in the parentEl,\n        //      and we need to keep track of their flowIndex\n        newFlowIndex += MutableNode.getFlowIndexFromNodes(newNodess[prevIdx])\n        // ---- Update the nodes\n        this.updateItem(newNodess[prevIdx], this.array[idx])\n        continue\n      }\n      const newNodes = this.getNewNodes(idx)\n      const count = MutableNode.appendNodesWithIndex(\n        newNodes,\n        parentEl,\n        newFlowIndex,\n        length\n      )\n      newFlowIndex += count\n      length += count\n      // ---- Add the new nodes\n      newNodess.splice(idx, 0, newNodes)\n      shuffleKeys.splice(idx, 0, key)\n    }\n\n    // ---- After adding and deleting, the only thing left is to reorder the nodes,\n    //      but if the keys are the same, we don't need to reorder\n    if (ForNode.arrayEqual(this.keys, shuffleKeys)) {\n      this.nodess = newNodess\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    newFlowIndex = flowIndex\n    const bufferNodes = []\n    // ---- 3. Replace the nodes in the same position using Fisher-Yates shuffle algorithm\n    for (let idx = 0; idx < this.keys.length; idx++) {\n      const key = this.keys[idx]\n      const prevIdx = shuffleKeys.indexOf(key)\n      const bufferedNode = bufferNodes[idx]\n      if (bufferedNode) {\n        // ---- If the node is buffered, we need to add it to the parentEl\n        const addedElNum = MutableNode.appendNodesWithIndex(\n          bufferedNode,\n          parentEl,\n          newFlowIndex + MutableNode.getFlowIndexFromNodes(bufferedNode),\n          length\n        )\n        newFlowIndex += addedElNum\n        length += addedElNum\n        bufferNodes[idx] = undefined\n      } else if (prevIdx === idx) {\n        // ---- If the node is in the same position, we don't need to do anything\n        newFlowIndex += MutableNode.getFlowIndexFromNodes(newNodess[idx])\n        continue\n      } else {\n        // ---- If the node is not in the same position, we need to buffer it\n        bufferNodes[this.keys.indexOf(shuffleKeys[idx])] = newNodess[idx]\n        const addedElNum = MutableNode.appendNodesWithIndex(\n          newNodess[prevIdx],\n          parentEl,\n          newFlowIndex,\n          length\n        )\n        newFlowIndex += addedElNum\n        length += addedElNum\n      }\n      // ---- Swap the nodes\n      const tempNewNodes: AnyDLNode[] = newNodess[idx]\n      newNodess[idx] = newNodess[prevIdx]\n      newNodess[prevIdx] = tempNewNodes\n      const tempKey = shuffleKeys[idx]\n      shuffleKeys[idx] = shuffleKeys[prevIdx]\n      shuffleKeys[prevIdx] = tempKey\n    }\n\n    this.nodess = newNodess\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Compare two arrays\n   * @param arr1\n   * @param arr2\n   * @returns\n   */\n  private static arrayEqual<T>(arr1: T[], arr2: T[]) {\n    if (arr1.length !== arr2.length) return false\n    return arr1.every((item, idx) => item === arr2[idx])\n  }\n}\n","import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class ExpNode extends MutableNode {\n  nodesFunc\n\n  /**\n   * @brief Constructor, Exp type, accept a function that returns a list of nodes\n   * @param nodesFunc\n   */\n  constructor(nodesFunc: () => AnyDLNode[]) {\n    super(DLNodeType.Exp)\n    this.nodesFunc = nodesFunc\n    this._$nodes = ExpNode.formatNodes(nodesFunc())\n  }\n\n  /**\n   * @brief Generate new nodes and replace the old nodes\n   */\n  update() {\n    const newNodes = this.geneNewNodesInEnv(() =>\n      ExpNode.formatNodes(this.nodesFunc())\n    )\n    this.removeNodes(this._$nodes!)\n    if (newNodes.length === 0) {\n      this._$nodes = []\n      return\n    }\n\n    // ---- Add new nodes\n    const parentEl = (this as AnyDLNode)._$parentEl\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n    const nextSibling = parentEl.childNodes[flowIndex]\n    MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n\n    this._$nodes = newNodes\n  }\n\n  /**\n   * @brief Format the nodes\n   * @param nodes\n   * @returns New nodes\n   */\n  private static formatNodes(nodes: AnyDLNode | AnyDLNode[]): AnyDLNode[] {\n    if (!Array.isArray(nodes)) nodes = [nodes]\n    return (\n      nodes\n        // ---- Flatten the nodes\n        .flat(1)\n        // ---- Filter out empty nodes\n        .filter(\n          (node: AnyDLNode) =>\n            node !== undefined && node !== null && typeof node !== \"boolean\"\n        )\n        .map((node: any) => {\n          // ---- If the node is a string, number or bigint, convert it to a text node\n          if (\n            typeof node === \"string\" ||\n            typeof node === \"number\" ||\n            typeof node === \"bigint\"\n          ) {\n            return document.createTextNode(`${node}`)\n          }\n          // ---- If the node has PropView, call it to get the view\n          if (\"propViewFunc\" in node) return node.build()\n          return node\n        })\n        // ---- Flatten the nodes again\n        .flat(1)\n    )\n  }\n}\n","import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class CondNode extends MutableNode {\n  condFunc\n  cond\n  depNum\n\n  /**\n   * @brief Constructor, If type, accept a function that returns a list of nodes\n   * @param caseFunc\n   */\n  constructor(condFunc: (thisCond: CondNode) => AnyDLNode[], depNum: number) {\n    super(DLNodeType.Cond)\n    this.condFunc = condFunc\n    this.depNum = depNum\n    this.cond = -1\n    this._$nodes = this.condFunc(this)\n  }\n\n  /**\n   * @brief Update the nodes in the environment\n   */\n  updateCond(): void {\n    const newNodes = this.geneNewNodesInEnv(() => this.condFunc(this))\n    // ---- If the new nodes are the same as the old nodes, we only need to update  children\n    if ((this as AnyDLNode).didntChange) {\n      ;(this as AnyDLNode).didntChange = false\n      return this.updateChildren()\n    }\n\n    // ---- Remove old nodes\n    this._$nodes && this._$nodes.length > 0 && this.removeNodes(this._$nodes)\n    if (this.cond === -1) {\n      // ---- No branch has been taken\n      this._$nodes = []\n      return\n    }\n    // ---- Add new nodes\n    const parentEl = (this as AnyDLNode)._$parentEl\n    // ---- Faster append with nextSibling rather than flowIndex\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n\n    const nextSibling = parentEl.childNodes[flowIndex]\n    MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n    this._$nodes = newNodes\n  }\n\n  /**\n   * @brief Update the children of IfNode\n   */\n  updateChildren(changed?: number): void {\n    this._$nodes![0]?._$updateFunc?.(changed ?? this.depNum)\n  }\n\n  /**\n   * @brief The update function of IfNode's childNodes is stored in the first child node\n   * @param changed\n   */\n  update(changed: number): void {\n    if (changed & this.depNum) return\n    this.updateChildren(changed)\n  }\n}\n","import { type AnyDLNode, DLNode, DLNodeType } from \"./DLNode\"\nimport { type CompNode } from \"./CompNode\"\n\ndeclare global {\n  interface Window {\n    DLEnvStore: EnvStoreClass\n  }\n}\n\nclass EnvStoreClass {\n  envs: Record<string, [any, AnyDLNode]> = {}\n  currentEnvNodes: EnvNode[] = []\n  /**\n   * @brief Add a node to the current env and merge envs\n   * @param node\n   */\n  addEnvNode(node: AnyDLNode): void {\n    this.currentEnvNodes.push(node)\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Replace the current env with the given nodes and merge envs\n   * @param nodes\n   */\n  replaceEnvNodes(nodes: AnyDLNode[]): void {\n    this.currentEnvNodes = nodes\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Remove the last node from the current env and merge envs\n   */\n  removeEnvNode(): void {\n    this.currentEnvNodes.pop()\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Merge all the envs in currentEnvNodes, inner envs override outer envs\n   */\n  private mergeEnvs(): void {\n    this.envs = {}\n    this.currentEnvNodes.forEach(envNode => {\n      Object.entries(envNode.envs).forEach(([key, value]) => {\n        this.envs[key] = [value, envNode]\n      })\n    })\n  }\n}\n\nif (!window.DLEnvStore) window.DLEnvStore = new EnvStoreClass()\n\nexport class EnvNode extends DLNode {\n  updateNodes = new Set<CompNode>()\n  envs\n\n  /**\n   * @brief Constructor, Env type, accept a record of envs, add this node to DLEnvStore\n   * @param envs\n   */\n  constructor(envs: Record<string, any>) {\n    super(DLNodeType.Env)\n    // ---- Must set this.envs before calling DLEnvStore.addEnvNode,\n    //      because DLEnvStore.addEnvNode will read this.envs and merge it with DLEnvStore.envs\n    this.envs = envs\n    window.DLEnvStore.addEnvNode(this)\n  }\n\n  /**\n   * @brief Update a specific env, and update all the comp nodes that depend on this env\n   * @param name\n   * @param value\n   */\n  updateEnv(name: string, value: any): void {\n    this.envs[name] = value\n    this.updateNodes.forEach(node => {\n      node._$updateEnv(name, value, this)\n    })\n  }\n\n  /**\n   * @brief Add a node to this.updateNodes, delete the node from this.updateNodes when it unmounts\n   * @param node\n   */\n  addNode(node: AnyDLNode): void {\n    this.updateNodes.add(node)\n    DLNode.addWillUnmount(\n      node,\n      this.updateNodes.delete.bind(this.updateNodes, node)\n    )\n  }\n\n  /**\n   * @brief Set this._$nodes, and exit the current env\n   * @param nodes\n   */\n  initNodes(nodes: AnyDLNode[]): void {\n    this._$nodes = nodes\n    window.DLEnvStore.removeEnvNode()\n  }\n}\n","/**\n * @brief Shorten document.createTextNode\n * @param value\n * @returns Text\n */\nexport function createTextNode(value: string): Text {\n  return document.createTextNode(value)\n}\n\n/**\n * @brief Update text node and check if the value is changed\n * @param node\n * @param value\n */\nexport function updateText(node: Text, value: string): void {\n  if (node.textContent === value) return\n  node.textContent = value\n}\n","import { DLNode, type AnyDLNode } from \"./DLNode\"\n\nexport class PropView {\n  propViewFunc\n  dlUpdateNodes = new Set<AnyDLNode>()\n\n  /**\n   * @brief PropView constructor, accept a function that returns a list of DLNode\n   * @param propViewFunc\n   */\n  constructor(propViewFunc: () => AnyDLNode[]) {\n    this.propViewFunc = propViewFunc\n  }\n\n  /**\n   * @brief Build the prop view by calling the propViewFunc and add every single instance of the returned DLNode to dlUpdateNodes\n   * @returns the list of DLNode returned by propViewFunc\n   */\n  build(): AnyDLNode[] {\n    const newNodes = this.propViewFunc()\n    if (newNodes.length === 0) return []\n    // ---- The update function is stored in the first node,\n    //      so we push every instance of the first node to dlUpdateNodes\n    const updateNode = newNodes[0]\n    this.dlUpdateNodes.add(updateNode)\n    // ---- Remove the updateNode from dlUpdateNodes when it unmounts\n    DLNode.addWillUnmount(\n      updateNode,\n      this.dlUpdateNodes.delete.bind(this.dlUpdateNodes, updateNode)\n    )\n\n    return newNodes\n  }\n\n  /**\n   * @brief Update every node in dlUpdateNodes\n   * @param changed\n   */\n  update(changed: number): void {\n    this.dlUpdateNodes.forEach(node => {\n      node._$updateFunc?.(changed)\n    })\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","$","CompNode","CondNode","EnvNode","ExpNode","ForNode","PropView","View","createElement","createTemplate","createTextNode","escape","forwardHTMLProp","insertNode","manual","render","setDataset","setEvent","setHTMLAttr","setHTMLAttrs","setHTMLProp","setHTMLProps","setStyle","update","updateText","__toCommonJS","DLNode","nodeType","nodes","els","el","runFunc","node","parentEl","stopNode","index","stack","nextSibling","length","count","currFunc","prevFunc","func","setStyle","el","value","key","setDataset","setHTMLProp","prevKey","setHTMLProps","setHTMLAttr","setHTMLAttrs","setEvent","prevEvent","createTemplate","templateStr","template","element","createElement","tag","insertNode","node","position","DLNode","forwardHTMLProp","CompNode","DLNode","props","content","children","forwardPropsScope","key","value","envNode","protoProps","ownProps","valueKey","node","forwardHTMLProp","contentKey","k","depNum","View","update","dlNode","MutableNode","DLNode","type","nodes","newNodesFunc","newNodes","currentEnvNodes","node","el","ForNode","MutableNode","array","nodeFunc","depNum","keys","item","changed","idx","nodes","newArray","newKeys","preLength","currLength","parentEl","flowIndex","length","newNodes","prevKeys","prevArray","prevNodess","parentNodes","prevIdx","nextSibling","shuffleKeys","newNodess","arrToUpdate","prevKey","newFlowIndex","key","count","bufferNodes","bufferedNode","addedElNum","tempNewNodes","tempKey","arr1","arr2","ExpNode","MutableNode","nodesFunc","newNodes","parentEl","flowIndex","nextSibling","nodes","node","CondNode","MutableNode","condFunc","depNum","newNodes","parentEl","flowIndex","nextSibling","changed","EnvStoreClass","node","nodes","envNode","key","value","EnvNode","DLNode","envs","name","createTextNode","value","updateText","node","PropView","propViewFunc","newNodes","updateNode","DLNode","changed","node","render","idOrEl","DL","el","elFound","dlNode","insertNode","manual","callback","_deps","escape","arg","$"]}
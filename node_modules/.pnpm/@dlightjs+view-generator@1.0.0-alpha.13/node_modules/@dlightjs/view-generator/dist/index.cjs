"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  generateSubView: () => generateSubView,
  generateView: () => generateView
});
module.exports = __toCommonJS(src_exports);

// src/error.ts
var import_error_handler = require("@dlightjs/error-handler");
var DLError = (0, import_error_handler.createErrorHandler)(
  "ViewGenerator",
  {
    1: "Element prop in HTML should be a function or an identifier",
    2: "Unrecognized HTML common prop",
    3: "Do prop only accepts function or arrow function"
  },
  {},
  {
    1: 'ExpressionNode only supports prop as ["element", "do"]'
  }
);

// src/HelperGenerators/BaseGenerator.ts
var devMode = process.env.NODE_ENV === "development";
var _BaseGenerator = class {
  viewParticle;
  config;
  t;
  traverse;
  className;
  importMap;
  subViewPropMap;
  viewGenerator;
  /**
   * @brief Constructor
   * @param viewUnit
   * @param config
   */
  constructor(viewParticle, config) {
    this.viewParticle = viewParticle;
    this.config = config;
    this.t = config.babelApi.types;
    this.traverse = config.babelApi.traverse;
    this.className = config.className;
    this.importMap = config.importMap;
    this.subViewPropMap = config.subViewPropMap;
    this.viewGenerator = new ViewGenerator(config);
  }
  // ---- Init Statements
  initStatements = [];
  addInitStatement(...statements) {
    this.initStatements.push(...statements);
  }
  // ---- Added Class Properties, typically used in for Template
  classProperties = [];
  addStaticClassProperty(key, value) {
    this.classProperties.push(
      this.t.classProperty(
        this.t.identifier(key),
        value,
        void 0,
        void 0,
        void 0,
        true
      )
    );
  }
  // ---- Update Statements
  updateStatements = {};
  addUpdateStatements(dependencies, statement) {
    if (!dependencies || dependencies.length === 0)
      return;
    const depNum = _BaseGenerator.calcDependencyNum(dependencies);
    if (!this.updateStatements[depNum])
      this.updateStatements[depNum] = [];
    this.updateStatements[depNum].push(statement);
  }
  addUpdateStatementsWithoutDep(statement) {
    if (!this.updateStatements[0])
      this.updateStatements[0] = [];
    this.updateStatements[0].push(statement);
  }
  /**
   * @returns [initStatements, updateStatements, classProperties, nodeName]
   */
  generate() {
    const nodeName = this.run();
    return [
      this.initStatements,
      this.updateStatements,
      this.classProperties,
      nodeName
    ];
  }
  /**
   * @brief Generate the view given the view particles, mainly used for child particles parsing
   * @param viewParticles
   * @param mergeStatements
   * @returns [initStatements, topLevelNodes, updateStatements]
   */
  generateChildren(viewParticles, mergeStatements = true) {
    this.viewGenerator.nodeIdx = this.nodeIdx;
    this.viewGenerator.templateIdx = this.templateIdx;
    const [initStatements, updateStatements, classProperties, topLevelNodes] = this.viewGenerator.generateChildren(viewParticles);
    this.nodeIdx = this.viewGenerator.nodeIdx;
    this.templateIdx = this.viewGenerator.templateIdx;
    this.classProperties.push(...classProperties);
    if (mergeStatements)
      this.mergeStatements(updateStatements);
    return [initStatements, topLevelNodes, updateStatements];
  }
  /**
   * @brief Merge the update statements
   * @param statements
   */
  mergeStatements(statements) {
    Object.entries(statements).forEach(([depNum, statements2]) => {
      if (!this.updateStatements[Number(depNum)]) {
        this.updateStatements[Number(depNum)] = [];
      }
      this.updateStatements[Number(depNum)].push(...statements2);
    });
  }
  /**
   * @brief Generate the view given the view particle
   * @param viewParticle
   * @param mergeStatements
   * @returns [initStatements, nodeName, updateStatements]
   */
  generateChild(viewParticle, mergeStatements = true) {
    this.viewGenerator.nodeIdx = this.nodeIdx;
    this.viewGenerator.templateIdx = this.templateIdx;
    const [initStatements, updateStatements, classProperties, nodeName] = this.viewGenerator.generateChild(viewParticle);
    this.nodeIdx = this.viewGenerator.nodeIdx;
    this.templateIdx = this.viewGenerator.templateIdx;
    this.classProperties.push(...classProperties);
    if (mergeStatements)
      this.mergeStatements(updateStatements);
    return [initStatements, nodeName, updateStatements];
  }
  /**
   * @View
   * this._$update = (changed) => {
   *   if (changed & 1) {
   *     ...
   *   }
   *   ...
   * }
   */
  geneUpdateBody(updateStatements) {
    return this.t.blockStatement([
      ...Object.entries(updateStatements).filter(([depNum]) => depNum !== "0").map(([depNum, statements]) => {
        return this.t.ifStatement(
          this.t.binaryExpression(
            "&",
            this.t.identifier("changed"),
            this.t.numericLiteral(Number(depNum))
          ),
          this.t.blockStatement(statements)
        );
      }),
      ...updateStatements[0] ?? []
    ]);
  }
  /**
   * @View
   * return [${topLevelNodes}]
   */
  generateReturnStatement(topLevelNodes) {
    return this.t.returnStatement(
      this.t.arrayExpression(topLevelNodes.map((name) => this.t.identifier(name)))
    );
  }
  /**
   * @brief To be implemented by the subclass as the main node generation function
   * @returns dlNodeName
   */
  run() {
    return "";
  }
  // ---- Name ----
  // ---- Used as dlNodeName for any node declaration
  nodeIdx = -1;
  generateNodeName(idx) {
    return `${_BaseGenerator.prefixMap.node}${idx ?? ++this.nodeIdx}`;
  }
  // ---- Used as template generation as class property
  templateIdx = -1;
  generateTemplateName() {
    return `${_BaseGenerator.prefixMap.template}${++this.templateIdx}`;
  }
  // ---- @Utils -----
  /**
   *
   * @param updateStatements
   * @returns
   */
  /**
   * @brief Calculate the dependency number from an array of dependency index
   *  e.g.
   *    [0, 1, 2] => 0b111 => 7
   *    [1, 3] => 0b1010 => 10
   * @param dependencies
   * @returns dependency number
   */
  static calcDependencyNum(dependencies) {
    if (!dependencies || dependencies.length === 0)
      return 0;
    dependencies = [...new Set(dependencies)];
    return dependencies.reduce((acc, dep) => acc + (1 << dep), 0);
  }
  /**
   * @brief Wrap the value in a file
   * @param node
   * @returns wrapped value
   */
  valueWrapper(node) {
    return this.t.file(
      this.t.program([
        this.t.isStatement(node) ? node : this.t.expressionStatement(node)
      ])
    );
  }
  /**
   * @brief Shorthand function for collecting statements in batch
   * @returns [statements, collect]
   */
  static statementsCollector() {
    const statements = [];
    const collect = (...newStatements) => {
      newStatements.forEach((s) => {
        if (Array.isArray(s)) {
          statements.push(...s);
        } else {
          statements.push(s);
        }
      });
    };
    return [statements, collect];
  }
};
var BaseGenerator = _BaseGenerator;
__publicField(BaseGenerator, "prefixMap", devMode ? { template: "$template", node: "$node" } : { template: "$t", node: "$n" });

// src/HelperGenerators/PropViewGenerator.ts
var PropViewGenerator = class extends BaseGenerator {
  /**
   * @brief Alter prop view in batch
   * @param props
   * @returns altered props
   */
  alterPropViews(props) {
    if (!props)
      return props;
    return Object.fromEntries(
      Object.entries(props).map(([key, prop]) => {
        return [key, this.alterPropView(prop)];
      })
    );
  }
  /**
   * @View
   * const ${dlNodeName} = new PropView(() => {
   *  ${initStatements}
   *  ${topLevelNodes[0])._$updateFunc = (changed) => { ${updateStatements} }
   *  return ${topLevelNodes}
   * })
   */
  declarePropView(viewParticles) {
    const [initStatements, topLevelNodes, updateStatements] = this.generateChildren(viewParticles, false);
    if (topLevelNodes.length > 0) {
      if (Object.keys(updateStatements).length > 0) {
        initStatements.push(
          this.t.expressionStatement(
            this.t.assignmentExpression(
              "=",
              this.t.memberExpression(
                this.t.identifier(topLevelNodes[0]),
                this.t.identifier("_$updateFunc")
              ),
              this.t.arrowFunctionExpression(
                [this.t.identifier("changed")],
                this.geneUpdateBody(updateStatements)
              )
            )
          )
        );
      }
      initStatements.push(this.generateReturnStatement(topLevelNodes));
    }
    const dlNodeName = this.generateNodeName();
    const propViewNode = this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(this.t.identifier(this.importMap.PropView), [
          this.t.arrowFunctionExpression(
            [],
            this.t.blockStatement(initStatements)
          )
        ])
      )
    ]);
    this.addInitStatement(propViewNode);
    const propViewIdentifier = this.t.identifier(dlNodeName);
    this.addUpdateStatementsWithoutDep(
      this.t.expressionStatement(
        this.t.callExpression(
          this.t.memberExpression(
            propViewIdentifier,
            this.t.identifier("update")
          ),
          [this.t.identifier("changed")]
        )
      )
    );
    return dlNodeName;
  }
  /**
   * @brief Alter prop view by replacing prop view with a recursively generated prop view
   * @param prop
   * @returns altered prop
   */
  alterPropView(prop) {
    if (!prop)
      return prop;
    const { value, viewPropMap } = prop;
    if (!viewPropMap)
      return { ...prop, value };
    let newValue = value;
    this.traverse(this.valueWrapper(value), {
      StringLiteral: (innerPath) => {
        const id = innerPath.node.value;
        const viewParticles = viewPropMap[id];
        if (!viewParticles)
          return;
        const propViewIdentifier = this.t.identifier(
          this.declarePropView(viewParticles)
        );
        if (value === innerPath.node)
          newValue = propViewIdentifier;
        innerPath.replaceWith(propViewIdentifier);
        innerPath.skip();
      }
    });
    return { ...prop, value: newValue };
  }
  /**
   * @brief Get the dependency index array from the update statements' keys
   *  i.e. [1, 2, 7] => [0b1, 0b10, 0b111] => [[1], [2], [0, 1, 2]] => [0, 1, 2]
   * @param updateStatements
   * @returns dependency index array
   */
  static reverseDependencyIndexArr(updateStatements) {
    const allDepsNum = Object.keys(updateStatements).map(Number).reduce((acc, depNum) => acc | depNum, 0);
    const allDeps = [];
    for (let i = 0; i < String(allDepsNum).length; i++) {
      if (allDepsNum & 1 << i)
        allDeps.push(i);
    }
    return allDeps;
  }
};

// src/HelperGenerators/DoGenerator.ts
var DoGenerator = class extends PropViewGenerator {
  /**
   * @View
   * ${value}(dlNodeName)
   */
  addDo(dlNodeName, value) {
    if (!this.t.isFunctionExpression(value) && !this.t.isArrowFunctionExpression(value)) {
      return DLError.throw1();
    }
    return this.t.expressionStatement(
      this.t.callExpression(value, [this.t.identifier(dlNodeName)])
    );
  }
};

// src/HelperGenerators/ElementGenerator.ts
var ElementGenerator = class extends DoGenerator {
  /**
   * @brief Generate a view unit for an element
   *  e.g. div().element(this.el)
   * @param dlNodeName
   * @param value
   * @param el true: dlNodeName._$el, false: dlNodeName
   * @returns t.Statement
   */
  setElement(dlNodeName, value, el = false) {
    const elNode = el ? this.t.memberExpression(
      this.t.identifier(dlNodeName),
      this.t.identifier("_$el")
    ) : this.t.identifier(dlNodeName);
    return this.isOnlyMemberExpression(value) ? this.assignHTMLElement(elNode, value) : this.assignHTMLFunctionElement(elNode, value);
  }
  /**
   * if (typeof ${value} === "function") {
   *  ${value}(${elNode})
   * } else {
   *  ${value} = ${elNode}
   * }
   */
  assignHTMLElement(elNode, value) {
    return this.t.ifStatement(
      this.t.binaryExpression(
        "===",
        this.t.unaryExpression("typeof", value, true),
        this.t.stringLiteral("function")
      ),
      this.t.expressionStatement(this.t.callExpression(value, [elNode])),
      this.t.expressionStatement(
        this.t.assignmentExpression("=", value, elNode)
      )
    );
  }
  /**
   * ${value}(${elNode})
   */
  assignHTMLFunctionElement(elNode, value) {
    if (!this.t.isFunctionExpression(value) && !this.t.isArrowFunctionExpression(value)) {
      return DLError.throw1();
    }
    return this.t.expressionStatement(this.t.callExpression(value, [elNode]));
  }
  // --- Utils
  isOnlyMemberExpression(value) {
    if (!this.t.isMemberExpression(value))
      return false;
    while (value.property) {
      if (this.t.isMemberExpression(value.property)) {
        value = value.property;
        continue;
      } else if (this.t.isIdentifier(value.property))
        break;
      else
        return false;
    }
    return true;
  }
};

// src/HelperGenerators/ForwardPropGenerator.ts
var ForwardPropsGenerator = class extends ElementGenerator {
  /**
   * @View
   * this._$forwardProp(${dlNodeName})
   */
  forwardProps(dlNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.thisExpression(),
          this.t.identifier("_$addForwardProps")
        ),
        [this.t.identifier(dlNodeName)]
      )
    );
  }
};

// src/NodeGenerators/CompGenerator.ts
var CompGenerator = class extends ForwardPropsGenerator {
  run() {
    let { content, props } = this.viewParticle;
    content = this.alterPropView(content);
    props = this.alterPropViews(props);
    const { tag, children } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(
      this.declareCompNode(dlNodeName, tag, content, props, children)
    );
    if (content) {
      const { value, dependencyIndexArr } = content;
      if (dependencyIndexArr && dependencyIndexArr.length > 0) {
        this.addUpdateStatements(
          dependencyIndexArr,
          this.setCompContent(dlNodeName, value)
        );
      }
    }
    if (props) {
      Object.entries(props).forEach(([key, { value, dependencyIndexArr }]) => {
        if (key === "do") {
          const statement = this.addDo(dlNodeName, value);
          this.addInitStatement(statement);
          this.addUpdateStatements(dependencyIndexArr, statement);
          return;
        }
        if (key === "element") {
          const statement = this.setElement(dlNodeName, value, true);
          this.addInitStatement(statement);
          this.addUpdateStatements(dependencyIndexArr, statement);
          return;
        }
        if (key === "forwardProps")
          return;
        if (dependencyIndexArr && dependencyIndexArr.length > 0) {
          this.addUpdateStatements(
            dependencyIndexArr,
            this.setCompProp(dlNodeName, key, value)
          );
        }
      });
    }
    return dlNodeName;
  }
  /**
   * @View
   * null
   *  or
   * { prop1: xxx, prop2: xxx, ... }
   */
  generateCompProps(props) {
    if (!props || Object.keys(props).length === 0)
      return this.t.nullLiteral();
    return this.t.objectExpression(
      Object.entries(props).map(
        ([key, { value }]) => this.t.objectProperty(this.t.identifier(key), value)
      )
    );
  }
  /**
   * @View
   * const ${dlNodeName} = new ${tag}(${props}, ${content}, ${children}, ${this})
   */
  declareCompNode(dlNodeName, tag, content, props, children) {
    let willForwardProps = false;
    if (props) {
      if ("forwardProps" in props)
        willForwardProps = true;
      props = Object.fromEntries(
        Object.entries(props).filter(
          ([key]) => !["do", "element", "forwardProps"].includes(key)
        )
      );
    }
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(tag, [
          this.generateCompProps(props),
          content?.value ?? this.t.nullLiteral(),
          children && children.length > 0 ? this.t.identifier(this.declarePropView(children)) : this.t.nullLiteral(),
          willForwardProps ? this.t.identifier("this") : this.t.nullLiteral()
        ])
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}._$setContent(${value})
   */
  setCompContent(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("_$setContent")
        ),
        [value]
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}._$setProp(${key}, ${value})
   */
  setCompProp(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("_$setProp")
        ),
        [this.t.stringLiteral(key), value]
      )
    );
  }
};

// src/attr.ts
var attributeMap = {
  // ---- Other property as attribute
  textContent: ["*"],
  innerHTML: ["*"],
  // ---- Source: https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes
  accept: ["form", "input"],
  // ---- Original: accept-charset
  acceptCharset: ["form"],
  accesskey: ["*"],
  action: ["form"],
  align: [
    "caption",
    "col",
    "colgroup",
    "hr",
    "iframe",
    "img",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  allow: ["iframe"],
  alt: ["area", "img", "input"],
  async: ["script"],
  autocapitalize: ["*"],
  autocomplete: ["form", "input", "select", "textarea"],
  autofocus: ["button", "input", "select", "textarea"],
  autoplay: ["audio", "video"],
  background: ["body", "table", "td", "th"],
  // ---- Original: base
  bgColor: [
    "body",
    "col",
    "colgroup",
    "marquee",
    "table",
    "tbody",
    "tfoot",
    "td",
    "th",
    "tr"
  ],
  border: ["img", "object", "table"],
  buffered: ["audio", "video"],
  capture: ["input"],
  charset: ["meta"],
  checked: ["input"],
  cite: ["blockquote", "del", "ins", "q"],
  class: ["*"],
  color: ["font", "hr"],
  cols: ["textarea"],
  // ---- Original: colspan
  colSpan: ["td", "th"],
  content: ["meta"],
  // ---- Original: contenteditable
  contentEditable: ["*"],
  contextmenu: ["*"],
  controls: ["audio", "video"],
  coords: ["area"],
  crossOrigin: ["audio", "img", "link", "script", "video"],
  csp: ["iframe"],
  data: ["object"],
  // ---- Original: datetime
  dateTime: ["del", "ins", "time"],
  decoding: ["img"],
  default: ["track"],
  defer: ["script"],
  dir: ["*"],
  dirname: ["input", "textarea"],
  disabled: [
    "button",
    "fieldset",
    "input",
    "optgroup",
    "option",
    "select",
    "textarea"
  ],
  download: ["a", "area"],
  draggable: ["*"],
  enctype: ["form"],
  // ---- Original: enterkeyhint
  enterKeyHint: ["textarea", "contenteditable"],
  for: ["label", "output"],
  form: [
    "button",
    "fieldset",
    "input",
    "label",
    "meter",
    "object",
    "output",
    "progress",
    "select",
    "textarea"
  ],
  // ---- Original: formaction
  formAction: ["input", "button"],
  // ---- Original: formenctype
  formEnctype: ["button", "input"],
  // ---- Original: formmethod
  formMethod: ["button", "input"],
  // ---- Original: formnovalidate
  formNoValidate: ["button", "input"],
  // ---- Original: formtarget
  formTarget: ["button", "input"],
  headers: ["td", "th"],
  height: ["canvas", "embed", "iframe", "img", "input", "object", "video"],
  hidden: ["*"],
  high: ["meter"],
  href: ["a", "area", "base", "link"],
  hreflang: ["a", "link"],
  // ---- Original: http-equiv
  httpEquiv: ["meta"],
  id: ["*"],
  integrity: ["link", "script"],
  // ---- Original: intrinsicsize
  intrinsicSize: ["img"],
  // ---- Original: inputmode
  inputMode: ["textarea", "contenteditable"],
  ismap: ["img"],
  // ---- Original: itemprop
  itemProp: ["*"],
  kind: ["track"],
  label: ["optgroup", "option", "track"],
  lang: ["*"],
  language: ["script"],
  loading: ["img", "iframe"],
  list: ["input"],
  loop: ["audio", "marquee", "video"],
  low: ["meter"],
  manifest: ["html"],
  max: ["input", "meter", "progress"],
  // ---- Original: maxlength
  maxLength: ["input", "textarea"],
  // ---- Original: minlength
  minLength: ["input", "textarea"],
  media: ["a", "area", "link", "source", "style"],
  method: ["form"],
  min: ["input", "meter"],
  multiple: ["input", "select"],
  muted: ["audio", "video"],
  name: [
    "button",
    "form",
    "fieldset",
    "iframe",
    "input",
    "object",
    "output",
    "select",
    "textarea",
    "map",
    "meta",
    "param"
  ],
  // ---- Original: novalidate
  noValidate: ["form"],
  open: ["details", "dialog"],
  optimum: ["meter"],
  pattern: ["input"],
  ping: ["a", "area"],
  placeholder: ["input", "textarea"],
  // ---- Original: playsinline
  playsInline: ["video"],
  poster: ["video"],
  preload: ["audio", "video"],
  readonly: ["input", "textarea"],
  // ---- Original: referrerpolicy
  referrerPolicy: ["a", "area", "iframe", "img", "link", "script"],
  rel: ["a", "area", "link"],
  required: ["input", "select", "textarea"],
  reversed: ["ol"],
  role: ["*"],
  rows: ["textarea"],
  // ---- Original: rowspan
  rowSpan: ["td", "th"],
  sandbox: ["iframe"],
  scope: ["th"],
  scoped: ["style"],
  selected: ["option"],
  shape: ["a", "area"],
  size: ["input", "select"],
  sizes: ["link", "img", "source"],
  slot: ["*"],
  span: ["col", "colgroup"],
  spellcheck: ["*"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ],
  srcdoc: ["iframe"],
  srclang: ["track"],
  srcset: ["img", "source"],
  start: ["ol"],
  step: ["input"],
  style: ["*"],
  summary: ["table"],
  // ---- Original: tabindex
  tabIndex: ["*"],
  target: ["a", "area", "base", "form"],
  title: ["*"],
  translate: ["*"],
  type: [
    "button",
    "input",
    "embed",
    "object",
    "ol",
    "script",
    "source",
    "style",
    "menu",
    "link"
  ],
  usemap: ["img", "input", "object"],
  value: [
    "button",
    "data",
    "input",
    "li",
    "meter",
    "option",
    "progress",
    "param",
    "text"
  ],
  width: ["canvas", "embed", "iframe", "img", "input", "object", "video"],
  wrap: ["textarea"]
};
var elementAttributeMap = Object.entries(attributeMap).reduce((acc, [key, elements]) => {
  elements.forEach((element) => {
    if (!acc[element])
      acc[element] = [];
    acc[element].push(key);
  });
  return acc;
}, {});
function isInternalAttribute(tag, attribute) {
  return elementAttributeMap["*"].includes(attribute) || elementAttributeMap[tag]?.includes(attribute);
}

// src/HelperGenerators/HTMLPropGenerator.ts
var HTMLPropGenerator = class extends ForwardPropsGenerator {
  /**
   * @brief Add any HTML props according to the key
   * @param name
   * @param tag
   * @param key
   * @param value
   * @param dependencyIndexArr
   * @returns t.Statement
   */
  addHTMLProp(name, tag, key, value, dependencyIndexArr) {
    if (dependencyIndexArr && dependencyIndexArr.length > 0) {
      const statement = this.setDynamicHTMLProp(name, tag, key, value);
      this.addUpdateStatements(dependencyIndexArr, statement);
      return statement;
    }
    return this.setStaticHTMLProp(name, tag, key, value);
  }
  /**
   * @View
   * insertNode(${dlNodeName}, ${childNodeName}, ${position})
   */
  insertNode(dlNodeName, childNodeName, position) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.insertNode), [
        this.t.identifier(dlNodeName),
        this.t.identifier(childNodeName),
        this.t.numericLiteral(position)
      ])
    );
  }
  /**
   * @View
   * setStyle(${dlNodeName}, ${value})
   */
  setHTMLStyle(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setStyle), [
        this.t.identifier(dlNodeName),
        value
      ])
    );
  }
  /**
   * @View
   * setStyle(${dlNodeName}, ${value})
   */
  setHTMLDataset(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setDataset), [
        this.t.identifier(dlNodeName),
        value
      ])
    );
  }
  /**
   * @View
   * ${dlNodeName}.${key} = ${value}
   */
  setHTMLProp(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.assignmentExpression(
        "=",
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier(key)
        ),
        value
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.setAttribute(${key}, ${value})
   */
  setHTMLAttr(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("setAttribute")
        ),
        [this.t.stringLiteral(key), value]
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.addEventListener(${key}, ${value})
   */
  setHTMLEvent(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("addEventListener")
        ),
        [this.t.stringLiteral(key), value]
      )
    );
  }
  /**
   * @View
   * setEvent(${dlNodeName}, ${key}, ${value})
   */
  setEvent(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setEvent), [
        this.t.identifier(dlNodeName),
        this.t.stringLiteral(key),
        value
      ])
    );
  }
  /**
   * @View
   * setHTMLProp(${dlNodeName}, ${key}, ${value})
   */
  setCachedProp(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setHTMLProp), [
        this.t.identifier(dlNodeName),
        this.t.stringLiteral(key),
        value
      ])
    );
  }
  /**
   * @View
   * setHTMLAttr(${dlNodeName}, ${key}, ${value})
   */
  setCachedAttr(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setHTMLAttr), [
        this.t.identifier(dlNodeName),
        this.t.stringLiteral(key),
        value
      ])
    );
  }
  /**
   * @View
   * ${setHTMLProps}(${dlNodeName}, ${value})
   */
  setHTMLPropObject(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setHTMLProps), [
        this.t.identifier(dlNodeName),
        value
      ])
    );
  }
  /**
   * @View
   * ${setHTMLAttrs}(${dlNodeName}, ${value})
   */
  setHTMLAttrObject(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.setHTMLAttrs), [
        this.t.identifier(dlNodeName),
        value
      ])
    );
  }
  commonHTMLPropKeys = [
    "style",
    "dataset",
    "element",
    "prop",
    "attr",
    "forwardProps"
  ];
  /**
   * For style/dataset/element/attr/prop
   */
  addCommonHTMLProp(dlNodeName, attrName, value) {
    if (attrName === "style")
      return this.setHTMLStyle(dlNodeName, value);
    if (attrName === "dataset")
      return this.setHTMLDataset(dlNodeName, value);
    if (attrName === "element")
      return this.setElement(dlNodeName, value);
    if (attrName === "prop")
      return this.setHTMLPropObject(dlNodeName, value);
    if (attrName === "attr")
      return this.setHTMLAttrObject(dlNodeName, value);
    if (attrName === "forwardProps")
      return this.forwardProps(dlNodeName);
    return DLError.throw2();
  }
  /**
   * @View
   * 1. Event listener
   *  - ${dlNodeName}.addEventListener(${key}, ${value})
   * 2. HTML internal attribute -> DOM property
   *  - ${dlNodeName}.${key} = ${value}
   * 3. HTML custom attribute
   *  - ${dlNodeName}.setAttribute(${key}, ${value})
   */
  setStaticHTMLProp(dlNodeName, tag, attrName, value) {
    if (this.commonHTMLPropKeys.includes(attrName))
      return this.addCommonHTMLProp(dlNodeName, attrName, value);
    if (attrName.startsWith("on")) {
      const eventName = attrName.slice(2).toLowerCase();
      return this.setHTMLEvent(dlNodeName, eventName, value);
    }
    if (isInternalAttribute(tag, attrName)) {
      if (attrName === "class")
        attrName = "className";
      else if (attrName === "for")
        attrName = "htmlFor";
      return this.setHTMLProp(dlNodeName, attrName, value);
    }
    return this.setHTMLAttr(dlNodeName, attrName, value);
  }
  /**
   * @View
   * 1. Event listener
   *  - ${setEvent}(${dlNodeName}, ${key}, ${value})
   * 2. HTML internal attribute -> DOM property
   *  - ${setHTMLProp}(${dlNodeName}, ${key}, ${value})
   * 3. HTML custom attribute
   *  - ${setHTMLAttr}(${dlNodeName}, ${key}, ${value})
   */
  setDynamicHTMLProp(dlNodeName, tag, attrName, value) {
    if (this.commonHTMLPropKeys.includes(attrName))
      return this.addCommonHTMLProp(dlNodeName, attrName, value);
    if (attrName.startsWith("on")) {
      const eventName = attrName.slice(2).toLowerCase();
      return this.setEvent(dlNodeName, eventName, value);
    }
    if (isInternalAttribute(tag, attrName)) {
      if (attrName === "class")
        attrName = "className";
      else if (attrName === "for")
        attrName = "htmlFor";
      return this.setCachedProp(dlNodeName, attrName, value);
    }
    return this.setCachedAttr(dlNodeName, attrName, value);
  }
};

// src/NodeGenerators/HTMLGenerator.ts
var HTMLGenerator = class extends HTMLPropGenerator {
  run() {
    const { tag, props, children } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareHTMLNode(dlNodeName, tag));
    if (props) {
      const tagName = this.t.isStringLiteral(tag) ? tag.value : "ANY";
      Object.entries(props).forEach(([key, { value, dependencyIndexArr }]) => {
        this.addInitStatement(
          this.addHTMLProp(dlNodeName, tagName, key, value, dependencyIndexArr)
        );
      });
    }
    if (children) {
      const childNames = [];
      children.forEach((child, idx) => {
        const [initStatements, childName] = this.generateChild(child);
        childNames.push(childName);
        this.addInitStatement(...initStatements);
        if (child.type === "html")
          this.addInitStatement(this.appendChild(dlNodeName, childName));
        else
          this.addInitStatement(this.insertNode(dlNodeName, childName, idx));
      });
      this.addInitStatement(this.setHTMLNodes(dlNodeName, childNames));
    }
    return dlNodeName;
  }
  /**
   * @View
   * const ${dlNodeName} = createElement(${tag})
   */
  declareHTMLNode(dlNodeName, tag) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.callExpression(this.t.identifier(this.importMap.createElement), [
          tag
        ])
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}._$nodes = [...${childNames}]
   */
  setHTMLNodes(dlNodeName, childNames) {
    return this.t.expressionStatement(
      this.t.assignmentExpression(
        "=",
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("_$nodes")
        ),
        this.t.arrayExpression(childNames.map((name) => this.t.identifier(name)))
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.appendChild(${childNodeName})
   */
  appendChild(dlNodeName, childNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("appendChild")
        ),
        [this.t.identifier(childNodeName)]
      )
    );
  }
};

// src/NodeGenerators/TemplateGenerator.ts
var TemplateGenerator = class extends HTMLPropGenerator {
  run() {
    const { template, mutableParticles, props } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    const templateName = this.addTemplate(template);
    this.addInitStatement(this.declareTemplateNode(dlNodeName, templateName));
    const paths = [];
    props.forEach(({ path }) => {
      paths.push(path);
    });
    mutableParticles.forEach(({ path }) => {
      paths.push(path.slice(0, -1));
    });
    const [insertElementStatements, pathNameMap] = this.insertElements(
      paths,
      dlNodeName
    );
    this.addInitStatement(...insertElementStatements);
    props.forEach(({ tag, path, key, value, dependencyIndexArr }) => {
      const name = pathNameMap[path.join(".")];
      this.addInitStatement(
        this.addHTMLProp(name, tag, key, value, dependencyIndexArr)
      );
    });
    mutableParticles.forEach((particle) => {
      const path = particle.path;
      const parentName = pathNameMap[path.slice(0, -1).join(".")];
      const [initStatements, childName] = this.generateChild(particle);
      this.addInitStatement(...initStatements);
      this.addInitStatement(
        this.insertNode(parentName, childName, path[path.length - 1])
      );
    });
    return dlNodeName;
  }
  /**
   * @View
   * static ${templateName} = ${createTemplate}(${templateString})
   */
  addTemplate(template) {
    const templateName = this.generateTemplateName();
    this.addStaticClassProperty(
      templateName,
      this.t.callExpression(this.t.identifier(this.importMap.createTemplate), [
        this.t.stringLiteral(template)
      ])
    );
    return templateName;
  }
  /**
   * @View
   * const ${dlNodeName} = ${this.className}.${templateName}()
   */
  declareTemplateNode(dlNodeName, templateName) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.callExpression(
          this.t.memberExpression(
            this.t.identifier(this.className),
            this.t.identifier(templateName)
          ),
          []
        )
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}.firstChild
   *  or
   * ${dlNodeName}.firstChild.nextSibling
   *  or
   * ...
   * ${dlNodeName}.childNodes[${num}]
   */
  insertElement(dlNodeName, path, offset) {
    const newNodeName = this.generateNodeName();
    if (path.length === 0) {
      return this.t.variableDeclaration("const", [
        this.t.variableDeclarator(
          this.t.identifier(newNodeName),
          Array.from({ length: offset }).reduce(
            (acc) => this.t.memberExpression(acc, this.t.identifier("nextSibling")),
            this.t.identifier(dlNodeName)
          )
        )
      ]);
    }
    const addFirstChild = (object) => (
      // ---- ${object}.firstChild
      this.t.memberExpression(object, this.t.identifier("firstChild"))
    );
    const addSecondChild = (object) => (
      // ---- ${object}.firstChild.nextSibling
      this.t.memberExpression(
        addFirstChild(object),
        this.t.identifier("nextSibling")
      )
    );
    const addThirdChild = (object) => (
      // ---- ${object}.firstChild.nextSibling.nextSibling
      this.t.memberExpression(
        addSecondChild(object),
        this.t.identifier("nextSibling")
      )
    );
    const addOtherChild = (object, num) => (
      // ---- ${object}.childNodes[${num}]
      this.t.memberExpression(
        this.t.memberExpression(object, this.t.identifier("childNodes")),
        this.t.numericLiteral(num),
        true
      )
    );
    const addNextSibling = (object) => (
      // ---- ${object}.nextSibling
      this.t.memberExpression(object, this.t.identifier("nextSibling"))
    );
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(newNodeName),
        path.reduce((acc, cur, idx) => {
          if (idx === 0 && offset > 0) {
            for (let i = 0; i < offset; i++)
              acc = addNextSibling(acc);
          }
          if (cur === 0)
            return addFirstChild(acc);
          if (cur === 1)
            return addSecondChild(acc);
          if (cur === 2)
            return addThirdChild(acc);
          return addOtherChild(acc, cur);
        }, this.t.identifier(dlNodeName))
      )
    ]);
  }
  /**
   * @brief Insert elements to the template node from the paths
   * @param paths
   * @param dlNodeName
   * @returns
   */
  insertElements(paths, dlNodeName) {
    const [statements, collect] = HTMLPropGenerator.statementsCollector();
    const nameMap = { [dlNodeName]: [] };
    const commonPrefixPaths = TemplateGenerator.pathWithCommonPrefix(paths);
    commonPrefixPaths.forEach((path) => {
      const res = TemplateGenerator.findBestNodeAndPath(
        nameMap,
        path,
        dlNodeName
      );
      const [, pat, offset] = res;
      let name = res[0];
      if (pat.length !== 0 || offset !== 0) {
        collect(this.insertElement(name, pat, offset));
        name = this.generateNodeName(this.nodeIdx);
        nameMap[name] = path;
      }
    });
    const pathNameMap = Object.fromEntries(
      Object.entries(nameMap).map(([name, path]) => [path.join("."), name])
    );
    return [statements, pathNameMap];
  }
  // ---- Path related
  /**
   * @brief Extract common prefix from paths
   *  e.g.
   *    [0, 1, 2, 3] + [0, 1, 2, 4] => [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 4]
   *  [0, 1, 2] is the common prefix
   * @param paths
   * @returns paths with common prefix
   */
  static pathWithCommonPrefix(paths) {
    const allPaths = [...paths];
    paths.forEach((path0) => {
      paths.forEach((path1) => {
        if (path0 === path1)
          return;
        for (let i = 0; i < path0.length; i++) {
          if (path0[i] !== path1[i]) {
            if (i !== 0) {
              allPaths.push(path0.slice(0, i));
            }
            break;
          }
        }
      });
    });
    const sortedPaths = allPaths.sort((a, b) => {
      if (a.length !== b.length)
        return a.length - b.length;
      return a[0] - b[0];
    });
    const deduplicatedPaths = [
      ...new Set(sortedPaths.map((path) => path.join(".")))
    ].map((path) => path.split(".").filter(Boolean).map(Number));
    return deduplicatedPaths;
  }
  /**
   * @brief Find the best node name and path for the given path by looking into the nameMap.
   *  If there's a full match, return the name and an empty path
   *  If there's a partly match, return the name and the remaining path
   *  If there's a nextSibling match, return the name and the remaining path with sibling offset
   * @param nameMap
   * @param path
   * @param defaultName
   * @returns [name, path, siblingOffset]
   */
  static findBestNodeAndPath(nameMap, path, defaultName) {
    let bestMatchCount = 0;
    let bestMatchName;
    let bestHalfMatch;
    Object.entries(nameMap).forEach(([name, pat]) => {
      let matchCount = 0;
      const pathLength = pat.length;
      for (let i = 0; i < pathLength; i++) {
        if (pat[i] === path[i])
          matchCount++;
      }
      if (matchCount === pathLength - 1) {
        const offset = path[pathLength - 1] - pat[pathLength - 1];
        if (offset > 0 && offset <= 3) {
          bestHalfMatch = [name, matchCount, offset];
        }
      }
      if (matchCount !== pat.length)
        return;
      if (matchCount > bestMatchCount) {
        bestMatchName = name;
        bestMatchCount = matchCount;
      }
    });
    if (!bestMatchName) {
      if (bestHalfMatch) {
        return [
          bestHalfMatch[0],
          path.slice(bestHalfMatch[1] + 1),
          bestHalfMatch[2]
        ];
      }
      return [defaultName, path, 0];
    }
    return [bestMatchName, path.slice(bestMatchCount), 0];
  }
};

// src/NodeGenerators/ForGenerator.ts
var ForGenerator = class extends BaseGenerator {
  run() {
    const { item, array, key, children } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(
      this.declareForNode(
        dlNodeName,
        array.value,
        item,
        children,
        BaseGenerator.calcDependencyNum(array.dependencyIndexArr),
        key
      )
    );
    this.addUpdateStatements(
      array.dependencyIndexArr,
      this.updateForNode(dlNodeName, array.value, item, key)
    );
    this.addUpdateStatementsWithoutDep(this.updateForNodeItem(dlNodeName));
    return dlNodeName;
  }
  /**
   * @View
   * const ${dlNodeName} = new ForNode(${array}, ${item} => {
   *   ${children}
   *   const $update = (changed, ${item}) => {
   *      if (changed & ${depNum}) {
   *        ${statements}
   *      }
   *      ${statements}
   *   }
   *   ${topLevelNodes[0])._$updateFunc = $update
   *   return [...${topLevelNodes}]
   * }, ${depNum}, ${array}.map(${item} => ${key}))
   */
  declareForNode(dlNodeName, array, item, children, depNum, key) {
    const [childStatements, topLevelNodes, updateStatements] = this.generateChildren(children, false);
    if (Object.keys(updateStatements).length > 0) {
      childStatements.push(
        this.t.expressionStatement(
          this.t.assignmentExpression(
            "=",
            this.t.memberExpression(
              this.t.identifier(topLevelNodes[0]),
              this.t.identifier("_$updateFunc")
            ),
            this.t.arrowFunctionExpression(
              [this.t.identifier("changed"), item],
              this.geneUpdateBody(updateStatements)
            )
          )
        )
      );
    }
    childStatements.push(this.generateReturnStatement(topLevelNodes));
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(this.t.identifier(this.importMap.ForNode), [
          array,
          this.t.arrowFunctionExpression(
            [item],
            this.t.blockStatement(childStatements)
          ),
          this.t.numericLiteral(depNum),
          ...this.getForKeyStatement(array, item, key)
        ])
      )
    ]);
  }
  /**
   * @View
   * ${array}.map(${item} => ${key})
   */
  getForKeyStatement(array, item, key) {
    if (key) {
      return [
        this.t.callExpression(
          this.t.memberExpression(array, this.t.identifier("map")),
          [this.t.arrowFunctionExpression([item], key)]
        )
      ];
    }
    return [];
  }
  /**
   * @View
   * ${dlNodeName}.updateArray(${array}, ${array}.map(${item} => ${key}))
   */
  updateForNode(dlNodeName, array, item, key) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("updateArray")
        ),
        [array, ...this.getForKeyStatement(array, item, key)]
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.update(changed)
   */
  updateForNodeItem(dlNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("update")
        ),
        [this.t.identifier("changed")]
      )
    );
  }
};

// src/HelperGenerators/CondGenerator.ts
var CondGenerator = class extends BaseGenerator {
  /**
   * @View
   * $thisCond.cond = ${idx}
   */
  geneCondIdx(idx) {
    return this.t.expressionStatement(
      this.t.assignmentExpression(
        "=",
        this.t.memberExpression(
          this.t.identifier("$thisCond"),
          this.t.identifier("cond")
        ),
        this.t.numericLiteral(idx)
      )
    );
  }
  /**
   * @View
   * if ($thisCond.cond === ${idx}) {
   *  $thisCond.didntChange = true
   *  return []
   * }
   */
  geneCondCheck(idx) {
    return this.t.ifStatement(
      this.t.binaryExpression(
        "===",
        this.t.memberExpression(
          this.t.identifier("$thisCond"),
          this.t.identifier("cond")
        ),
        this.t.numericLiteral(idx)
      ),
      this.t.blockStatement([
        this.t.expressionStatement(
          this.t.assignmentExpression(
            "=",
            this.t.memberExpression(
              this.t.identifier("$thisCond"),
              this.t.identifier("didntChange")
            ),
            this.t.booleanLiteral(true)
          )
        ),
        this.t.returnStatement(this.t.arrayExpression([]))
      ])
    );
  }
  /**
   * @View
   * ${dlNodeName}.updateCond()
   */
  updateCondNodeCond(dlNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("updateCond")
        ),
        []
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.update(changed)
   */
  updateCondNode(dlNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("update")
        ),
        [this.t.identifier("changed")]
      )
    );
  }
  /**
   * @View
   * const ${dlNodeName} = new CondNode(($thisCond) => {}, ${depNum})
   */
  declareCondNode(dlNodeName, condFunc, deps) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(this.t.identifier(this.importMap.CondNode), [
          this.t.arrowFunctionExpression(
            [this.t.identifier("$thisCond")],
            condFunc
          ),
          this.t.numericLiteral(CondGenerator.calcDependencyNum(deps))
        ])
      )
    ]);
  }
};

// src/NodeGenerators/IfGenerator.ts
var IfGenerator = class extends CondGenerator {
  run() {
    const { branches } = this.viewParticle;
    const deps = branches.flatMap(
      ({ condition }) => condition.dependencyIndexArr ?? []
    );
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareIfNode(dlNodeName, branches, deps));
    this.addUpdateStatements(deps, this.updateCondNodeCond(dlNodeName));
    this.addUpdateStatementsWithoutDep(this.updateCondNode(dlNodeName));
    return dlNodeName;
  }
  /**
   * @View
   * ${firstNode}._$updateFunc = (changed) => { ${updateStatements} }
   */
  geneUpdateFunc(firstNode, updateStatements) {
    return this.t.expressionStatement(
      this.t.assignmentExpression(
        "=",
        this.t.memberExpression(
          this.t.identifier(firstNode),
          this.t.identifier("_$updateFunc")
        ),
        this.t.arrowFunctionExpression(
          [this.t.identifier("changed")],
          this.geneUpdateBody(updateStatements)
        )
      )
    );
  }
  /**
   * @View
   * if (${test}) { ${body} } else { ${alternate} }
   */
  geneIfStatement(test, body, alternate) {
    return this.t.ifStatement(test, this.t.blockStatement(body), alternate);
  }
  /**
   * @View
   * const ${dlNodeName} = new IfNode(($thisCond) => {
   *   if (cond1) {
   *    if ($thisCond.cond === 0) return
   *    ${children}
   *    $thisCond.cond = 0
   *    node0.update = () => {}
   *    return [nodes]
   *   } else if (cond2) {
   *    if ($thisCond.cond === 1) return
   *    ${children}
   *    $thisCond.cond = 1
   *    return [nodes]
   *   }
   * })
   */
  declareIfNode(dlNodeName, branches, deps) {
    const ifStatement = branches.reverse().reduce((acc, { condition, children }, idx) => {
      const [childStatements, topLevelNodes, updateStatements] = this.generateChildren(children, false);
      childStatements.unshift(this.geneCondCheck(branches.length - idx - 1));
      if (Object.keys(updateStatements).length > 0) {
        childStatements.push(
          this.geneUpdateFunc(topLevelNodes[0], updateStatements)
        );
      }
      childStatements.push(this.geneCondIdx(branches.length - idx - 1));
      childStatements.push(this.generateReturnStatement(topLevelNodes));
      if (idx === 0) {
        if (this.t.isBooleanLiteral(condition.value, { value: true })) {
          return this.t.blockStatement(childStatements);
        }
        return this.geneIfStatement(
          condition.value,
          childStatements,
          this.t.blockStatement([
            this.geneCondIdx(-1),
            this.generateReturnStatement([])
          ])
        );
      }
      return this.geneIfStatement(condition.value, childStatements, acc);
    }, void 0);
    return this.declareCondNode(
      dlNodeName,
      this.t.blockStatement([ifStatement]),
      deps
    );
  }
};

// src/NodeGenerators/EnvGenerator.ts
var EnvGenerator = class extends PropViewGenerator {
  run() {
    let { props } = this.viewParticle;
    props = this.alterPropViews(props);
    const { children } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareEnvNode(dlNodeName, props));
    this.addInitStatement(this.geneEnvChildren(dlNodeName, children));
    Object.entries(props).forEach(([key, { dependencyIndexArr, value }]) => {
      if (!dependencyIndexArr)
        return;
      this.addUpdateStatements(
        dependencyIndexArr,
        this.updateEnvNode(dlNodeName, key, value)
      );
    });
    return dlNodeName;
  }
  /**
   * @View
   * { ${key}: ${value}, ... }
   */
  generateEnvs(props) {
    return this.t.objectExpression(
      Object.entries(props).map(
        ([key, { value }]) => this.t.objectProperty(this.t.identifier(key), value)
      )
    );
  }
  /**
   * @View
   * const ${dlNodeName} = new EnvNode(envs)
   */
  declareEnvNode(dlNodeName, props) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(this.t.identifier(this.importMap.EnvNode), [
          this.generateEnvs(props)
        ])
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}.initNodes([${childrenNames}])
   */
  geneEnvChildren(dlNodeName, children) {
    const [statements, childrenNames] = this.generateChildren(children);
    this.addInitStatement(...statements);
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("initNodes")
        ),
        [
          this.t.arrayExpression(
            childrenNames.map((name) => this.t.identifier(name))
          )
        ]
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}.updateEnv(${key}, ${value})
   */
  updateEnvNode(dlNodeName, key, value) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("updateEnv")
        ),
        [this.t.stringLiteral(key), value]
      )
    );
  }
};

// src/NodeGenerators/TextGenerator.ts
var TextGenerator = class extends BaseGenerator {
  run() {
    const { content } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareTextNode(dlNodeName, content.value));
    if (content.dependencyIndexArr && content.dependencyIndexArr.length > 0) {
      this.addUpdateStatements(
        content.dependencyIndexArr,
        this.updateTextNode(dlNodeName, content.value)
      );
    }
    return dlNodeName;
  }
  /**
   * @View
   * const ${dlNodeName} = createTextNode(${value})
   */
  declareTextNode(dlNodeName, value) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.callExpression(
          this.t.identifier(this.importMap.createTextNode),
          [value]
        )
      )
    ]);
  }
  /**
   * @View
   * updateText(${dlNodeName}, ${value})
   */
  updateTextNode(dlNodeName, value) {
    return this.t.expressionStatement(
      this.t.callExpression(this.t.identifier(this.importMap.updateText), [
        this.t.identifier(dlNodeName),
        value
      ])
    );
  }
};

// src/NodeGenerators/ExpGenerator.ts
var ExpGenerator = class extends ElementGenerator {
  run() {
    let { content, props } = this.viewParticle;
    content = this.alterPropView(content);
    props = this.alterPropViews(props);
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareExpNode(dlNodeName, content.value));
    if (content.dependencyIndexArr && content.dependencyIndexArr.length > 0) {
      this.addUpdateStatements(
        content.dependencyIndexArr,
        this.updateExpNode(dlNodeName)
      );
    }
    if (props) {
      Object.entries(props).forEach(([key, { value, dependencyIndexArr }]) => {
        const statement = this.setExpProp(dlNodeName, key, value);
        if (statement) {
          this.addInitStatement(statement);
          dependencyIndexArr = [
            ...dependencyIndexArr ?? [],
            ...content.dependencyIndexArr ?? []
          ];
          if (dependencyIndexArr.length > 0) {
            this.addUpdateStatements(dependencyIndexArr, statement);
          }
        }
      });
    }
    return dlNodeName;
  }
  /**
   * @brief Expression node only supports `element` and `do` props
   * @param dlNodeName
   * @param key
   * @param value
   * @returns
   */
  setExpProp(dlNodeName, key, value) {
    if (key === "element")
      return this.setElement(dlNodeName, value, true);
    if (key === "do")
      return this.addDo(dlNodeName, value);
    return DLError.warn1();
  }
  /**
   * @View
   * const ${dlNodeName} = new ExpNode(() => ${value})
   */
  declareExpNode(dlNodeName, value) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.newExpression(this.t.identifier(this.importMap.ExpNode), [
          this.t.arrowFunctionExpression([], value)
        ])
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}.update()
   */
  updateExpNode(dlNodeName) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("update")
        ),
        []
      )
    );
  }
};

// src/NodeGenerators/SubViewGenerator.ts
var SubViewGenerator = class extends PropViewGenerator {
  run() {
    let { props } = this.viewParticle;
    props = this.alterPropViews(props);
    const { tag } = this.viewParticle;
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(this.declareSubviewNode(dlNodeName, tag, props ?? {}));
    const availableProperties = this.subViewPropMap[tag] ?? [];
    if (props) {
      Object.entries(props).forEach(([key, { value, dependencyIndexArr }]) => {
        if (!dependencyIndexArr || dependencyIndexArr.length === 0)
          return;
        const depIdx = availableProperties.indexOf(key);
        const propChange = 1 << depIdx;
        this.addUpdateStatements(
          dependencyIndexArr,
          this.updateProp(dlNodeName, propChange, key, value)
        );
      });
    }
    this.addUpdateStatementsWithoutDep(this.updateSubView(dlNodeName));
    return dlNodeName;
  }
  /**
   * @View
   * { ${key}: ${value}, ... }
   */
  genePropNode(props) {
    return this.t.objectExpression(
      Object.entries(props).map(([key, prop]) => {
        return this.t.objectProperty(this.t.identifier(key), prop.value);
      })
    );
  }
  /**
   * @View
   * const ${dlNodeName} = this.${tag}({${props}})
   */
  declareSubviewNode(dlNodeName, tag, props) {
    return this.t.variableDeclaration("const", [
      this.t.variableDeclarator(
        this.t.identifier(dlNodeName),
        this.t.callExpression(
          this.t.memberExpression(
            this.t.thisExpression(),
            this.t.identifier(tag)
          ),
          [this.genePropNode(props)]
        )
      )
    ]);
  }
  /**
   * @View
   * ${dlNodeName}.updateProp(${propChanged}, { ${key}: ${value} })
   */
  updateProp(dlNodeName, propChanged, key, value) {
    return this.t.expressionStatement(
      this.t.optionalCallExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("updateProp")
        ),
        [
          this.t.numericLiteral(propChanged),
          this.t.objectExpression([
            this.t.objectProperty(this.t.identifier(key), value)
          ])
        ],
        true
      )
    );
  }
  /**
   * @View
   * ${dlNodeName}?.update(changed)
   */
  updateSubView(dlNodeName) {
    return this.t.expressionStatement(
      this.t.optionalCallExpression(
        this.t.memberExpression(
          this.t.identifier(dlNodeName),
          this.t.identifier("update")
        ),
        [this.t.identifier("changed")],
        true
      )
    );
  }
};

// src/NodeGenerators/SwitchGenerator.ts
var SwitchGenerator = class extends CondGenerator {
  run() {
    const { branches, discriminant } = this.viewParticle;
    const deps = branches.flatMap(
      ({ case: _case }) => _case?.dependencyIndexArr ?? []
    );
    deps.push(...discriminant.dependencyIndexArr ?? []);
    const dlNodeName = this.generateNodeName();
    this.addInitStatement(
      this.declareSwitchNode(dlNodeName, discriminant.value, branches, deps)
    );
    this.addUpdateStatements(deps, this.updateCondNodeCond(dlNodeName));
    this.addUpdateStatementsWithoutDep(this.updateCondNode(dlNodeName));
    return dlNodeName;
  }
  /**
   * @View
   * _$updates.push((changed) => { ${updateStatements} })
   */
  geneUpdateFunc(updateStatements) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier("_$updates"),
          this.t.identifier("push")
        ),
        [
          this.t.arrowFunctionExpression(
            [this.t.identifier("changed")],
            this.geneUpdateBody(updateStatements)
          )
        ]
      )
    );
  }
  /**
   * @View
   * _$nodes.push(${nodeNames})
   */
  addNodes(nodeNames) {
    return this.t.expressionStatement(
      this.t.callExpression(
        this.t.memberExpression(
          this.t.identifier("_$nodes"),
          this.t.identifier("push")
        ),
        nodeNames.map((nodeName) => this.t.identifier(nodeName))
      )
    );
  }
  /**
   * @View
   * if (_$notSetCond) {
   *  $thisCond.cond = ${idx}
   *  _$notSetCond = false
   * }
   */
  geneCaseIdx(idx) {
    return this.t.ifStatement(
      this.t.identifier("_$notSetCond"),
      this.t.blockStatement([
        this.geneCondIdx(idx),
        this.t.expressionStatement(
          this.t.assignmentExpression(
            "=",
            this.t.identifier("_$notSetCond"),
            this.t.booleanLiteral(false)
          )
        )
      ])
    );
  }
  /**
   * @View
   * const _$nodes = []
   * const _$updates = []
   * let _$notSetCond = true
   */
  declareSwitchVariables(needToUpdate) {
    return [
      this.t.variableDeclaration("const", [
        this.t.variableDeclarator(
          this.t.identifier("_$nodes"),
          this.t.arrayExpression([])
        )
      ]),
      ...needToUpdate ? [
        this.t.variableDeclaration("const", [
          this.t.variableDeclarator(
            this.t.identifier("_$updates"),
            this.t.arrayExpression([])
          )
        ])
      ] : [],
      this.t.variableDeclaration("let", [
        this.t.variableDeclarator(
          this.t.identifier("_$notSetCond"),
          this.t.booleanLiteral(true)
        )
      ])
    ];
  }
  /**
   * @View
   *  _$nodes[0]._$updateFunc = (changed) => {
   *    _$updates.forEach(update => update(changed))
   *  })
   */
  addUpdateToTheFirstNode() {
    return this.t.expressionStatement(
      this.t.assignmentExpression(
        "=",
        this.t.memberExpression(
          this.t.memberExpression(
            this.t.identifier("_$nodes"),
            this.t.numericLiteral(0),
            true
          ),
          this.t.identifier("_$updateFunc")
        ),
        this.t.arrowFunctionExpression(
          [this.t.identifier("changed")],
          this.t.blockStatement([
            this.t.expressionStatement(
              this.t.callExpression(
                this.t.memberExpression(
                  this.t.identifier("_$updates"),
                  this.t.identifier("forEach")
                ),
                [
                  this.t.arrowFunctionExpression(
                    [this.t.identifier("update")],
                    this.t.blockStatement([
                      this.t.expressionStatement(
                        this.t.callExpression(this.t.identifier("update"), [
                          this.t.identifier("changed")
                        ])
                      )
                    ])
                  )
                ]
              )
            )
          ])
        )
      )
    );
  }
  /**
   * @View
   * const ${dlNodeName} = new CondNode(($thisCond) => {
   *   const _$nodes = []
   *   const _$updates = []
   *   let _$notSetCond = false
   *   switch ($discriminant) {
   *    case ${case0}:
   *      if ($thisCond.case === 0) return
   *    case ${case1}:
   *      if ($thisCond.case === 1) return
   *      return [...${case1Nodes}]
   *    default:
   *      if ($thisCond.case === 2) return
   *  }
   *   _$nodes[0]._$updateFunc = (changed) => {
   *    _$updates.forEach(update => update(changed))
   *  })
   *   return _$nodes
   * })
   */
  declareSwitchNode(dlNodeName, discriminant, branches, deps) {
    let needToUpdate = false;
    const switchStatements = branches.map(
      ({ case: _case, break: _break, children }, idx) => {
        const [childStatements, topLevelNodes, updateStatements] = this.generateChildren(children, false);
        childStatements.unshift(this.geneCondCheck(idx));
        if (Object.keys(updateStatements).length > 0) {
          childStatements.push(this.geneUpdateFunc(updateStatements));
          needToUpdate = true;
        }
        childStatements.push(this.addNodes(topLevelNodes));
        childStatements.push(this.geneCaseIdx(idx));
        if (_break)
          childStatements.push(this.t.breakStatement());
        return this.t.switchCase(_case ? _case.value : null, childStatements);
      }
    );
    return this.declareCondNode(
      dlNodeName,
      this.t.blockStatement([
        ...this.declareSwitchVariables(needToUpdate),
        this.t.switchStatement(discriminant, switchStatements),
        ...needToUpdate ? [this.addUpdateToTheFirstNode()] : [],
        this.t.returnStatement(this.t.identifier("_$nodes"))
      ]),
      deps
    );
  }
};

// src/ViewGenerator.ts
var _ViewGenerator = class {
  config;
  t;
  /**
   * @brief Construct the view generator from config
   * @param config
   */
  constructor(config) {
    this.config = config;
    this.t = config.babelApi.types;
    this.templateIdx = config.templateIdx;
  }
  /**
   * @brief Generate the view given the view particles, mainly used for child particles parsing
   * @param viewParticles
   * @returns [initStatements, updateStatements, classProperties, topLevelNodes]
   */
  generateChildren(viewParticles) {
    const allInitStatements = [];
    const allClassProperties = [];
    const allUpdateStatements = {};
    const topLevelNodes = [];
    viewParticles.forEach((viewParticle) => {
      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);
      allInitStatements.push(...initStatements);
      Object.entries(updateStatements).forEach(([depNum, statements]) => {
        if (!allUpdateStatements[Number(depNum)]) {
          allUpdateStatements[Number(depNum)] = [];
        }
        allUpdateStatements[Number(depNum)].push(...statements);
      });
      allClassProperties.push(...classProperties);
      topLevelNodes.push(nodeName);
    });
    return [
      allInitStatements,
      allUpdateStatements,
      allClassProperties,
      topLevelNodes
    ];
  }
  nodeIdx = -1;
  templateIdx = -1;
  /**
   * @brief Generate the view given the view particle, using generator from the map
   * @param viewParticle
   * @returns
   */
  generateChild(viewParticle) {
    const { type } = viewParticle;
    const GeneratorClass = _ViewGenerator.generatorMap[type];
    if (!GeneratorClass) {
      throw new Error(`Unknown view particle type: ${type}`);
    }
    const generator = new GeneratorClass(viewParticle, this.config);
    generator.nodeIdx = this.nodeIdx;
    generator.templateIdx = this.templateIdx;
    const result = generator.generate();
    this.nodeIdx = generator.nodeIdx;
    this.templateIdx = generator.templateIdx;
    return result;
  }
};
var ViewGenerator = _ViewGenerator;
/**
 * @brief Different generator classes for different view particle types
 */
__publicField(ViewGenerator, "generatorMap", {
  comp: CompGenerator,
  html: HTMLGenerator,
  template: TemplateGenerator,
  for: ForGenerator,
  if: IfGenerator,
  switch: SwitchGenerator,
  env: EnvGenerator,
  text: TextGenerator,
  exp: ExpGenerator,
  subview: SubViewGenerator
});

// src/MainViewGenerator.ts
var MainViewGenerator = class extends ViewGenerator {
  /**
   * @brief Generate the main view, i.e., View() { ... }
   * @param viewParticles
   * @returns [viewBody, classProperties, templateIdx]
   */
  generate(viewParticles) {
    const allClassProperties = [];
    const allInitStatements = [];
    const allUpdateStatements = {};
    const topLevelNodes = [];
    viewParticles.forEach((viewParticle) => {
      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);
      allInitStatements.push(...initStatements);
      Object.entries(updateStatements).forEach(([depNum, statements]) => {
        if (!allUpdateStatements[Number(depNum)]) {
          allUpdateStatements[Number(depNum)] = [];
        }
        allUpdateStatements[Number(depNum)].push(...statements);
      });
      allClassProperties.push(...classProperties);
      topLevelNodes.push(nodeName);
    });
    const viewBody = this.t.blockStatement([
      ...allInitStatements,
      ...this.geneUpdate(allUpdateStatements),
      this.geneReturn(topLevelNodes)
    ]);
    return [viewBody, allClassProperties, this.templateIdx];
  }
  /**
   * @View
   * this._$update = (changed) => {
   *  if (changed & 1) {
   *    ...
   *  }
   *  ...
   * }
   */
  geneUpdate(updateStatements) {
    if (Object.keys(updateStatements).length === 0)
      return [];
    return [
      this.t.expressionStatement(
        this.t.assignmentExpression(
          "=",
          this.t.memberExpression(
            this.t.thisExpression(),
            this.t.identifier("_$update"),
            false
          ),
          this.t.arrowFunctionExpression(
            [this.t.identifier("changed")],
            this.t.blockStatement([
              ...Object.entries(updateStatements).filter(([depNum]) => depNum !== "0").map(([depNum, statements]) => {
                return this.t.ifStatement(
                  this.t.binaryExpression(
                    "&",
                    this.t.identifier("changed"),
                    this.t.numericLiteral(Number(depNum))
                  ),
                  this.t.blockStatement(statements)
                );
              }),
              ...updateStatements[0] ?? []
            ])
          )
        )
      )
    ];
  }
  /**
   * @View
   * return [${nodeNames}]
   */
  geneReturn(topLevelNodes) {
    return this.t.returnStatement(
      this.t.arrayExpression(
        topLevelNodes.map((nodeName) => this.t.identifier(nodeName))
      )
    );
  }
};

// src/SubViewGenerator.ts
var SubViewGenerator2 = class extends ViewGenerator {
  /**
   * @brief Generate the subview, i.e., @View MySubView({ prop1, prop2 }) { ... }
   *  This is different from the main view in that it has a props node
   *  and is needed to parse twice,
   *    1. for this.deps (viewParticlesWithPropertyDep)
   *    2. for props that passed in this subview (viewParticlesWithIdentityDep)
   * @param viewParticlesWithPropertyDep
   * @param viewParticlesWithIdentityDep
   * @param propsNode
   * @returns [viewBody, classProperties, templateIdx]
   */
  generate(viewParticlesWithPropertyDep, viewParticlesWithIdentityDep, propsNode) {
    const allClassProperties = [];
    const allInitStatements = [];
    const propertyUpdateStatements = {};
    const identifierUpdateStatements = {};
    const topLevelNodes = [];
    const templateIdx = this.templateIdx;
    viewParticlesWithPropertyDep.forEach((viewParticle) => {
      const [initStatements, updateStatements, classProperties, nodeName] = this.generateChild(viewParticle);
      allInitStatements.push(...initStatements);
      Object.entries(updateStatements).forEach(([depNum, statements]) => {
        if (!propertyUpdateStatements[Number(depNum)]) {
          propertyUpdateStatements[Number(depNum)] = [];
        }
        propertyUpdateStatements[Number(depNum)].push(...statements);
      });
      allClassProperties.push(...classProperties);
      topLevelNodes.push(nodeName);
    });
    this.templateIdx = templateIdx;
    this.nodeIdx = -1;
    viewParticlesWithIdentityDep.forEach((viewParticle) => {
      const [, updateStatements] = this.generateChild(viewParticle);
      Object.entries(updateStatements).forEach(([depNum, statements]) => {
        if (!identifierUpdateStatements[Number(depNum)]) {
          identifierUpdateStatements[Number(depNum)] = [];
        }
        identifierUpdateStatements[Number(depNum)].push(...statements);
      });
    });
    const viewBody = this.t.blockStatement([
      ...allInitStatements,
      this.geneReturn(
        topLevelNodes,
        propertyUpdateStatements,
        identifierUpdateStatements,
        propsNode
      )
    ]);
    return [viewBody, allClassProperties, this.templateIdx];
  }
  /**
   * @View
   * (changed) => {
   *  if (changed & 1) {
   *    ...
   *  }
   *  ...
   * }
   */
  geneUpdateBody(updateStatements, propsNode) {
    const args = [this.t.identifier("changed")];
    if (propsNode) {
      args.push(this.t.identifier("$subviewProps"));
    }
    if (propsNode) {
      propsNode.properties.filter((prop) => this.t.isObjectProperty(prop)).forEach((prop, idx) => {
        const depNum = 1 << idx;
        if (!updateStatements[depNum])
          updateStatements[depNum] = [];
        updateStatements[depNum].unshift(
          this.t.expressionStatement(
            this.t.assignmentExpression(
              "=",
              this.t.objectPattern([prop]),
              this.t.identifier("$subviewProps")
            )
          )
        );
      });
    }
    const runAllStatements = propsNode ? [] : updateStatements[0] ?? [];
    return this.t.arrowFunctionExpression(
      args,
      this.t.blockStatement([
        ...Object.entries(updateStatements).filter(([depNum]) => depNum !== "0").map(([depNum, statements]) => {
          return this.t.ifStatement(
            this.t.binaryExpression(
              "&",
              this.t.identifier("changed"),
              this.t.numericLiteral(Number(depNum))
            ),
            this.t.blockStatement(statements)
          );
        }),
        ...runAllStatements
      ])
    );
  }
  /**
   * @View
   * return {
   *  _$dlNodeType: 5,
   *  update: ${this.geneUpdateBody(propertyUpdateStatements)},
   *  updateProp: ${this.geneUpdateBody(identifierUpdateStatements)},
   *  nodes: [${topLevelNodes}]
   * }
   */
  geneReturn(topLevelNodes, propertyUpdateStatements, identifierUpdateStatements, propsNode) {
    const propertyUpdate = Object.keys(propertyUpdateStatements).length > 0 ? [
      this.t.objectProperty(
        this.t.identifier("update"),
        this.geneUpdateBody(propertyUpdateStatements)
      )
    ] : [];
    const identifierUpdate = Object.keys(identifierUpdateStatements).filter((n) => n !== "0").length > 0 ? [
      this.t.objectProperty(
        this.t.identifier("updateProp"),
        this.geneUpdateBody(identifierUpdateStatements, propsNode)
      )
    ] : [];
    return this.t.returnStatement(
      this.t.objectExpression([
        this.t.objectProperty(
          this.t.identifier("_$dlNodeType"),
          this.t.numericLiteral(5)
        ),
        ...propertyUpdate,
        ...identifierUpdate,
        this.t.objectProperty(
          this.t.identifier("_$nodes"),
          this.t.arrayExpression(
            topLevelNodes.map((nodeName) => this.t.identifier(nodeName))
          )
        )
      ])
    );
  }
};

// src/index.ts
function generateView(viewParticles, config) {
  return new MainViewGenerator(config).generate(viewParticles);
}
function generateSubView(viewParticlesWithPropertyDep, viewParticlesWithIdentityDep, propNode, config) {
  return new SubViewGenerator2(config).generate(
    viewParticlesWithPropertyDep,
    viewParticlesWithIdentityDep,
    propNode
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateSubView,
  generateView
});
//# sourceMappingURL=index.cjs.map
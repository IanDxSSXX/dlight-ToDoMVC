{
  "version": 3,
  "sources": ["../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/DLNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/HTMLNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/CompNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/MutableNode/MutableNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/MutableNode/ForNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/MutableNode/ExpNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/MutableNode/CondNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/EnvNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/TextNode.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/PropView.ts", "../../.pnpm/@dlightjs+dlight@1.0.0-alpha.23/node_modules/@dlightjs/dlight/src/index.ts"],
  "sourcesContent": ["export type AnyDLNode = any\n\nexport enum DLNodeType {\n  Comp = 0,\n  For,\n  Cond,\n  Env,\n  Exp,\n  Subview,\n}\n\nexport class DLNode {\n  /**\n   * @brief Node type: HTML, Text, Custom, For, If, Env, Expression\n   */\n  _$dlNodeType: DLNodeType\n\n  /**\n   * @brief Constructor\n   * @param nodeType\n   */\n  constructor(nodeType: DLNodeType) {\n    this._$dlNodeType = nodeType\n  }\n\n  /**\n   * @brief Node element\n   *  Either one real element for HTMLNode and TextNode\n   *  Or an array of DLNode for CustomNode, ForNode, IfNode, EnvNode, ExpNode\n   */\n  get _$el(): HTMLElement[] {\n    return DLNode.toEls(this._$nodes!)\n  }\n\n  /**\n   * @brief Parent dom element, will be passed to child nodes\n   */\n  _$parentEl?: HTMLElement\n\n  /**\n   * @brief Child DLNodes\n   */\n  _$nodes?: AnyDLNode[]\n\n  /**\n   * @brief Loop all child DLNodes to get all the child elements\n   * @param nodes\n   * @returns HTMLElement[]\n   */\n  private static toEls(nodes: DLNode[]): HTMLElement[] {\n    const els: HTMLElement[] = []\n    this.loopShallowEls(nodes, el => {\n      els.push(el)\n    })\n    return els\n  }\n\n  // ---- Loop nodes ----\n  /**\n   * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopDLNodes(nodes: AnyDLNode[], runFunc: (node: AnyDLNode) => void) {\n    nodes.forEach(node => {\n      runFunc(node)\n      node._$nodes && DLNode.loopDLNodes(node._$nodes, runFunc)\n    })\n  }\n\n  /**\n   * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopDLNodesInsideOut(\n    nodes: AnyDLNode[],\n    runFunc: (node: AnyDLNode) => void\n  ) {\n    nodes.forEach(node => {\n      node._$nodes && DLNode.loopDLNodesInsideOut(node._$nodes, runFunc)\n      runFunc(node)\n    })\n  }\n\n  /**\n   * @brief Loop all elements shallowly,\n   *  i.e., don't loop the child nodes of dom elements and only call runFunc on dom elements\n   * @param nodes\n   * @param runFunc\n   */\n  static loopShallowEls(\n    nodes: AnyDLNode[],\n    runFunc: (node: AnyDLNode) => void\n  ) {\n    nodes.forEach(node => {\n      if (!(\"_$dlNodeType\" in node)) return runFunc(node)\n      node._$nodes && DLNode.loopShallowEls(node._$nodes, runFunc)\n    })\n  }\n\n  /**\n   * @brief Loop all nodes shallowly,\n   *  i.e., don't loop the child nodes of dom elements and call runFunc on all nodes\n   * @param nodes\n   * @param runFunc\n   */\n  static loopShallowDLNodes(nodes: any[], runFunc: (node: any) => void): void {\n    nodes.forEach(node => {\n      if (\"_$dlNodeType\" in node) {\n        runFunc(node)\n        node._$nodes && DLNode.loopShallowDLNodes(node._$nodes, runFunc)\n      }\n    })\n  }\n\n  /**\n   * @brief Add parentEl to all nodes until the first element\n   * @param nodes\n   * @param parentEl\n   */\n  static addParentEl(nodes: AnyDLNode[], parentEl: HTMLElement): void {\n    this.loopShallowDLNodes(nodes, node => {\n      node._$parentEl = parentEl\n    })\n  }\n\n  // ---- Flow index and add child elements ----\n  /**\n   * @brief Get the total count of dom elements before the stop node\n   * @param nodes\n   * @param stopNode\n   * @returns total count of dom elements\n   */\n  static getFlowIndexFromNodes(\n    nodes: AnyDLNode[],\n    stopNode?: AnyDLNode\n  ): number {\n    let index = 0\n    const stack = [...nodes]\n    while (stack.length > 0) {\n      const node = stack.shift()!\n      if (node === stopNode) break\n      if (\"_$dlNodeType\" in node) {\n        node._$nodes && stack.unshift(...node._$nodes)\n      } else {\n        index++\n      }\n    }\n    return index\n  }\n\n  /**\n   * @brief Given an array of nodes, append them to the parentEl\n   *  1. If nextSibling is provided, insert the nodes before the nextSibling\n   *  2. If nextSibling is not provided, append the nodes to the parentEl\n   * @param nodes\n   * @param parentEl\n   * @param nextSibling\n   * @returns Added element count\n   */\n  static appendNodesWithSibling(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    nextSibling: HTMLElement | undefined\n  ): number {\n    if (nextSibling) return this.insertNodesBefore(nodes, parentEl, nextSibling)\n    return this.appendNodes(nodes, parentEl)\n  }\n\n  /**\n   * @brief Given an array of nodes, append them to the parentEl using the index\n   *  1. If the index is the same as the length of the parentEl.childNodes, append the nodes to the parentEl\n   *  2. If the index is not the same as the length of the parentEl.childNodes, insert the nodes before the node at the index\n   * @param nodes\n   * @param parentEl\n   * @param index\n   * @param length\n   * @returns Added element count\n   */\n  static appendNodesWithIndex(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    index: number,\n    length?: number\n  ): number {\n    length = length ?? parentEl.childNodes.length\n    if (length !== index)\n      return this.insertNodesBefore(\n        nodes,\n        parentEl,\n        parentEl.childNodes[index] as any\n      )\n    return this.appendNodes(nodes, parentEl)\n  }\n\n  /**\n   * @brief Insert nodes before the nextSibling\n   * @param nodes\n   * @param parentEl\n   * @param nextSibling\n   * @returns Added element count\n   */\n  static insertNodesBefore(\n    nodes: AnyDLNode[],\n    parentEl: HTMLElement,\n    nextSibling: HTMLElement\n  ): number {\n    let count = 0\n    this.loopShallowEls(nodes, el => {\n      parentEl.insertBefore(el, nextSibling)\n      count++\n    })\n    return count\n  }\n\n  /**\n   * @brief Append nodes to the parentEl\n   * @param nodes\n   * @param parentEl\n   * @returns Added element count\n   */\n  static appendNodes(nodes: any[], parentEl: HTMLElement): number {\n    let count = 0\n    this.loopShallowEls(nodes, el => {\n      parentEl.appendChild(el)\n      count++\n    })\n    return count\n  }\n\n  private static willUnmountFunc(currFunc: () => void, prevFunc?: () => void) {\n    currFunc()\n    prevFunc?.()\n  }\n\n  // ---- Lifecycle ----\n  static addWillUnmount(node: AnyDLNode, func: () => void) {\n    node.willUnmount = this.willUnmountFunc.bind(this, func, node.willUnmount)\n  }\n}\n", "import { DLNode, type AnyDLNode } from \"./DLNode\"\n\n/**\n * @brief Plainly set style\n * @param el\n * @param value\n */\nexport function setStyle(el: HTMLElement, value: CSSStyleDeclaration): void {\n  Object.entries(value).forEach(([key, value]) => {\n    el.style[key as any] = value\n  })\n}\n\n/**\n * @brief Plainly set dataset\n * @param el\n * @param value\n */\nexport function setDataset(\n  el: HTMLElement,\n  value: Record<string, string>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    el.dataset[key] = value\n  })\n}\n\n/**\n * @brief Set HTML property with checking value equality first\n * @param el\n * @param key\n * @param value\n */\nexport function setHTMLProp(\n  el: HTMLElement,\n  key: keyof HTMLElement,\n  value: any\n): void {\n  const prevKey = `$${key}`\n  if (prevKey in el && (el as AnyDLNode)[prevKey] === value) return\n  ;(el as AnyDLNode)[key] = value\n  ;(el as AnyDLNode)[prevKey] = value\n}\n\n/**\n * @brief Plainly set HTML properties\n * @param el\n * @param value\n */\nexport function setHTMLProps(\n  el: HTMLElement,\n  value: Record<string, any>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    setHTMLProp(el, key as any, value)\n  })\n}\n\n/**\n * @brief Set HTML attribute with checking value equality first\n * @param el\n * @param key\n * @param value\n */\nexport function setHTMLAttr(el: HTMLElement, key: string, value: any): void {\n  const prevKey = `$${key}`\n  if (prevKey in el && (el as AnyDLNode)[prevKey] === value) return\n  el.setAttribute(key, value)\n  ;(el as AnyDLNode)[prevKey] = value\n}\n\n/**\n * @brief Plainly set HTML attributes\n * @param el\n * @param value\n */\nexport function setHTMLAttrs(\n  el: HTMLElement,\n  value: Record<string, any>\n): void {\n  Object.entries(value).forEach(([key, value]) => {\n    setHTMLAttr(el, key, value)\n  })\n}\n\n/**\n * @brief Set memorized event, store the previous event in el[`$on${key}`], if it exists, remove it first\n * @param el\n * @param key\n * @param value\n */\nexport function setEvent(el: HTMLElement, key: string, value: any): void {\n  const prevEvent = (el as any)[`$on${key}`]\n  if (prevEvent) el.removeEventListener(key, prevEvent)\n  el.addEventListener(key, value)\n  ;(el as any)[`$on${key}`] = value\n}\n\n/**\n * @brief Create a template function, which returns a function that returns a cloned element\n * @param templateStr\n * @returns a function that returns a cloned element\n */\nexport function createTemplate(templateStr: string): () => HTMLElement {\n  const template = document.createElement(\"template\")\n  template.innerHTML = templateStr\n\n  const element = template.content.firstChild\n  return () => element!.cloneNode(true) as HTMLElement\n}\n\n/**\n * @brief Shortcut for document.createElement\n * @param tag\n * @returns HTMLElement\n */\nexport function createElement(tag: string): HTMLElement {\n  return document.createElement(tag)\n}\n\n/**\n * @brief Insert any DLNode into an element, set the _$nodes and append the element to the element's children\n * @param el\n * @param node\n * @param position\n */\nexport function insertNode(\n  el: HTMLElement,\n  node: AnyDLNode,\n  position: number\n): void {\n  // ---- Set _$nodes\n  if (!(el as AnyDLNode)._$nodes)\n    (el as AnyDLNode)._$nodes = Array.from(el.childNodes)\n  ;(el as AnyDLNode)._$nodes.splice(position, 0, node)\n\n  // ---- Insert nodes' elements\n  DLNode.appendNodesWithIndex([node], el, position)\n  // ---- Set parentEl\n  DLNode.addParentEl([node], el)\n}\n\n/**\n * @brief An inclusive assign prop function that accepts any type of prop\n * @param el\n * @param key\n * @param value\n */\nexport function forwardHTMLProp(\n  el: HTMLElement,\n  key: string,\n  value: any\n): void {\n  if (key === \"style\") {\n    setStyle(el, value)\n    return\n  }\n  if (key === \"dataset\") {\n    setDataset(el, value)\n    return\n  }\n  if (key === \"element\") return\n  if (key === \"prop\") {\n    setHTMLProps(el, value)\n    return\n  }\n  if (key === \"attr\") {\n    setHTMLAttrs(el, value)\n    return\n  }\n  if (key === \"innerHTML\") {\n    setHTMLProp(el, \"innerHTML\", value)\n    return\n  }\n  if (key === \"forwardProp\") return\n  if (key.startsWith(\"on\")) {\n    setEvent(el, key.slice(2).toLowerCase(), value)\n    return\n  }\n  setHTMLAttr(el, key, value)\n}\n", "import { type AnyDLNode, DLNode, DLNodeType } from \"./DLNode\"\nimport { type EnvNode } from \"./EnvNode\"\nimport { forwardHTMLProp } from \"./HTMLNode\"\n\nexport class CompNode extends DLNode {\n  /**\n   * @brief Constructor, Comp type\n   * @internal\n   *  * key - getter: return $key\n   *  * key - setter: set $key, update $s$key, call update function with $$key\n   *  * $key - private property key\n   *  * $$key - dependency number, e.g. 0b1, 0b10, 0b100\n   *  * $s$key - set of properties that depend on this property\n   *  * $p$key - exist if this property is a prop\n   *  * $e$key - exist if this property is an env\n   *  * $en$key - exist if this property is an env, and it's the innermost env that contains this env\n   *  * $w$key - exist if this property is a watcher\n   *  * $f$key - a function that returns the value of this property, called when the property's dependencies change\n   *  * _$children - children nodes of type PropView\n   *  * _$contentKey - the key key of the content prop\n   *  * _$forwardProps - exist if this node is forwarding props\n   *  * _$forwardPropsId - the keys of the props that this node is forwarding, collected in _$setForwardProp\n   *  * _$forwardPropsSet - contain all the nodes that are forwarding props to this node, collected with _$addForwardProps\n   */\n  constructor() {\n    super(DLNodeType.Comp)\n  }\n\n  /**\n   * @brief Init function, called explicitly in the subclass's constructor\n   * @param props\n   * @param content\n   * @param children\n   * @param forwardPropsScope\n   */\n  _$init(\n    props: Record<string, any> | null,\n    content: any | null,\n    children: AnyDLNode[] | null,\n    forwardPropsScope: CompNode | null\n  ): void {\n    // ---- Add props\n    // ---- Forward props first to allow internal props to override forwarded props\n    if (forwardPropsScope) forwardPropsScope._$addForwardProps(this)\n    if (content !== null) this._$setContent(content)\n    if (props) {\n      Object.entries(props).forEach(([key, value]) => {\n        this._$setProp(key, value)\n      })\n    }\n    if (children) (this as AnyDLNode)._$children = children\n\n    // ---- Add envs\n    Object.entries(window.DLEnvStore.envs).forEach(\n      ([key, [value, envNode]]) => {\n        // ---- Add this node to every envNode's updateNodes\n        envNode.addNode(this)\n        this._$initEnv(key, value, envNode)\n      }\n    )\n\n    // ---- Call watchers\n    this._$callUpdatesBeforeInit()\n    // ---- init\n    ;(this as AnyDLNode).willMount?.()\n    this._$nodes = (this as AnyDLNode).View?.() ?? []\n    ;(this as AnyDLNode).didMount?.()\n  }\n\n  /**\n   * @brief Call updates manually before the node is mounted\n   */\n  private _$callUpdatesBeforeInit(): void {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n    const ownProps = Object.getOwnPropertyNames(this)\n    const allProps = [...protoProps, ...ownProps]\n    allProps.forEach(key => {\n      if (key.startsWith(\"$w$\")) return (this as any)[key.slice(3)]()\n      if (key.startsWith(\"$f$\")) {\n        ;(this as any)[`$${key.slice(3)}`] = (this as any)[key]\n      }\n    })\n  }\n\n  /**\n   * @brief Define forward props\n   * @param key\n   * @param value\n   */\n  private _$setForwardProp(key: string, value: any): void {\n    // ---- If the prop is already defined, don't forward it\n    if (key in this) {\n      ;(this as AnyDLNode)[key] = value\n      return\n    }\n    ;(this as AnyDLNode)._$forwardPropsId.push(key)\n    const valueKey = `$${key}`\n    ;(this as AnyDLNode)[valueKey] = value\n    Object.defineProperty(this, key, {\n      get() {\n        return this[valueKey]\n      },\n      set(value) {\n        if (this[valueKey] === value) return\n        this[valueKey] = value\n        // ---- Don't need to call update function because the prop is not a explicit dependency\n        ;(this as AnyDLNode)._$forwardPropsSet?.forEach((node: AnyDLNode) => {\n          // ---- Directly set the prop if it's a CompNode\n          if (node._$dlNodeType === DLNodeType.Comp) node._$setProp(key, value)\n          // ---- Different behavior for HTMLNode according to the key\n          if (node instanceof HTMLElement) forwardHTMLProp(node, key, value)\n        })\n      },\n    })\n  }\n\n  /**\n   * @brief Add a node to the set of nodes that are forwarding props to this node and init these props, called\n   *  1. HTMLNode: explicitly in the View function\n   *  2. CompNode: passed in the node's constructor and called in _$init to make sure it's added before the node is mounted\n   * @param node\n   */\n  _$addForwardProps(node: AnyDLNode): void {\n    // ---- Add node to the set of nodes that are forwarding props to this node\n    ;(this as AnyDLNode)._$forwardPropsSet.add(node)\n    // ---- Init these forwarded props\n    ;(this as AnyDLNode)._$forwardPropsId.forEach((key: string) => {\n      const value = (this as AnyDLNode)[key]\n      ;(this as AnyDLNode)._$forwardPropsSet?.forEach((node: AnyDLNode) => {\n        // ---- Directly set the prop if it's a CompNode\n        if (node._$dlNodeType === DLNodeType.Comp) {\n          // ---- Pass down forwardProps\n          if (\"_$forwardProps\" in node) node._$forwardPropsId.push(key)\n          node._$setProp(key, value)\n        }\n        // ---- Different behavior for HTMLNode according to the key\n        if (node instanceof HTMLElement) forwardHTMLProp(node, key, value)\n      })\n    })\n    // ---- Remove current node from the set of forwarding nodes when it's unmounted\n    DLNode.addWillUnmount(\n      node,\n      (this as AnyDLNode)._$forwardPropsSet.delete.bind(\n        (this as AnyDLNode)._$forwardPropsSet,\n        node\n      )\n    )\n  }\n\n  /**\n   * @brief Set a prop directly, if this is a forwarded prop, go and init forwarded props\n   * @param key\n   * @param value\n   */\n  _$setProp(key: string, value: any): void {\n    if (\"_$forwardProps\" in this) this._$setForwardProp(key, value)\n    if (!(`$p$${key}` in this)) return\n    ;(this as AnyDLNode)[key] = value\n  }\n\n  /**\n   * @brief Init an env, put the corresponding innermost envNode in $en$key\n   * @param key\n   * @param value\n   * @param envNode\n   */\n  private _$initEnv(key: string, value: any, envNode: EnvNode): void {\n    if (!(`$e$${key}` in this)) return\n    ;(this as AnyDLNode)[key] = value\n    ;(this as AnyDLNode)[`$en$${key}`] = envNode\n  }\n\n  /**\n   * @brief Update an env, called in EnvNode._$update\n   * @param key\n   * @param value\n   * @param envNode\n   */\n  _$updateEnv(key: string, value: any, envNode: EnvNode): void {\n    if (!(`$e$${key}` in this)) return\n    // ---- Make sure the envNode is the innermost envNode that contains this env\n    if (envNode !== (this as AnyDLNode)[`$en$${key}`]) return\n    if ((this as AnyDLNode)[key] === value) return\n    ;(this as AnyDLNode)[key] = value\n  }\n\n  /**\n   * @brief Set the content prop, the key is stored in _$contentKey\n   * @param value\n   * @returns\n   */\n  _$setContent(value: any) {\n    const contentKey = (this as AnyDLNode)._$contentKey\n    if (!contentKey) return\n    if ((this as AnyDLNode)[contentKey] === value) return\n    ;(this as AnyDLNode)[contentKey] = value\n  }\n\n  /**\n   * @brief Update a prop and call any related update function\n   * @param key\n   * @param value\n   */\n  _$updateProp(key: string, value: any): void {\n    const valueKey = `$${key}`\n    if ((this as AnyDLNode)[valueKey] === value) return\n    ;(this as AnyDLNode)[valueKey] = value\n    this._$updateDerived(key)\n    this._$updateView(key)\n  }\n\n  /**\n   * @brief Update properties that depend on this property\n   * @param key\n   */\n  _$updateDerived(key: string): void {\n    // ---- Call update manually before the node is mounted, not here\n    if (!(this as AnyDLNode)._$nodes) return\n    ;(this as AnyDLNode)[`$s$${key}`]?.forEach((k: string) => {\n      // ---- Not time consuming at all\n      if (`$w$${k}` in (this as AnyDLNode)) {\n        ;(this as AnyDLNode)[k]()\n      } else {\n        ;(this as AnyDLNode)[`$${k}`] = (this as AnyDLNode)[`$f$${k}`]\n      }\n    })\n  }\n\n  /**\n   * @brief Update View related update function\n   * @param key\n   */\n  _$updateView(key: string): void {\n    const depNum = (this as AnyDLNode)[`$$${key}`]\n    if (!depNum) return // ---- Run update function\n    ;(this as AnyDLNode)._$update?.(depNum)\n  }\n}\n\n// ---- @View -> class Comp extends View\nexport const View = CompNode as any\n\n/**\n * @brief Run all update functions given the key\n * @param dlNode\n * @param key\n */\nexport function update(dlNode: AnyDLNode, key: string): void {\n  dlNode._$updateDerived(key)\n  dlNode._$updateView(key)\n}\n", "import { type AnyDLNode, DLNode } from \"../DLNode\"\n\nexport class MutableNode extends DLNode {\n  /**\n   * @brief Mutable node is a node that this._$nodes can be changed, things need to pay attention:\n   *  1. The environment of the new nodes should be the same as the old nodes\n   *  2. The new nodes should be added to the parentEl\n   *  3. The old nodes should be removed from the parentEl\n   * @param type\n   */\n  constructor(type: number) {\n    super(type)\n    // ---- Save the current environment nodes, must be a new reference\n    if (window.DLEnvStore.currentEnvNodes.length > 0) {\n      ;(this as AnyDLNode).savedEnvNodes = [\n        ...window.DLEnvStore.currentEnvNodes,\n      ]\n    }\n  }\n\n  /**\n   * @brief Initialize the new nodes, add parentEl to all nodes\n   * @param nodes\n   */\n  private initNewNodes(nodes: AnyDLNode[]): void {\n    // ---- Add parentEl to all nodes\n    DLNode.addParentEl(nodes, (this as AnyDLNode)._$parentEl)\n  }\n\n  /**\n   * @brief Generate new nodes in the saved environment\n   * @param newNodesFunc\n   * @returns\n   */\n  geneNewNodesInEnv(newNodesFunc: () => AnyDLNode[]): AnyDLNode[] {\n    if (!(this as AnyDLNode).savedEnvNodes) {\n      // ---- No saved environment, just generate new nodes\n      const newNodes = newNodesFunc()\n      // ---- Only for IfNode's same condition return\n      // ---- Initialize the new nodes\n      this.initNewNodes(newNodes)\n      return newNodes\n    }\n    // ---- Save the current environment nodes\n    const currentEnvNodes = window.DLEnvStore.currentEnvNodes\n    // ---- Replace the saved environment nodes\n    window.DLEnvStore.replaceEnvNodes((this as AnyDLNode).savedEnvNodes)\n    const newNodes = newNodesFunc()\n    // ---- Retrieve the current environment nodes\n    window.DLEnvStore.replaceEnvNodes(currentEnvNodes)\n    // ---- Only for IfNode's same condition return\n    // ---- Initialize the new nodes\n    this.initNewNodes(newNodes)\n    return newNodes\n  }\n\n  removeNodes(nodes: any[]) {\n    DLNode.loopDLNodes(nodes, node => node.willUnmount?.())\n    DLNode.loopShallowEls(nodes, el => {\n      this._$parentEl?.removeChild(el)\n    })\n    DLNode.loopDLNodesInsideOut(nodes, node => node.didUnmount?.())\n  }\n}\n", "import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class ForNode<T, G> extends MutableNode {\n  array\n  keys?\n  nodeFunc\n  nodess\n  depNum\n\n  /**\n   * @brief Constructor, For type\n   * @param array\n   * @param nodeFunc\n   * @param keys\n   */\n  constructor(\n    array: T[],\n    nodeFunc: (item: T) => AnyDLNode[],\n    depNum: number,\n    keys?: G[]\n  ) {\n    super(DLNodeType.For)\n    this.array = [...array]\n    this.nodeFunc = nodeFunc\n    this.keys = keys\n    this.depNum = depNum\n\n    this.nodess = this.array.map(item => nodeFunc(item))\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Non-array update function\n   * @param changed\n   */\n  update(changed: number): void {\n    if (changed & this.depNum) return\n    for (let idx = 0; idx < this.array.length; idx++) {\n      this.updateItem(this.nodess[idx], this.array[idx], changed)\n    }\n  }\n\n  /**\n   * @brief Update the view related to one item in the array\n   * @param nodes\n   * @param item\n   */\n  private updateItem(nodes: AnyDLNode[], item: T, changed?: number): void {\n    // ---- The update function of ForNode's childNodes is stored in the first child node\n    nodes[0]._$updateFunc?.(changed ?? this.depNum, item)\n  }\n\n  /**\n   * @brief Array-related update function\n   * @param newArray\n   * @param newKeys\n   */\n  updateArray(newArray: T[], newKeys?: G[]): void {\n    if (newKeys) {\n      this.updateWithKey(newArray, newKeys)\n      return\n    }\n    this.updateWithOutKey(newArray)\n  }\n\n  /**\n   * @brief Shortcut to generate new nodes with idx\n   */\n  private getNewNodes(idx: number) {\n    return this.geneNewNodesInEnv(() => this.nodeFunc(this.array[idx]))\n  }\n\n  /**\n   * @brief Update the nodes without keys\n   * @param newArray\n   */\n  private updateWithOutKey(newArray: T[]): void {\n    const preLength = this.array.length\n    const currLength = newArray.length\n    this.array = [...newArray]\n\n    if (preLength === currLength) {\n      // ---- If the length is the same, we only need to update the nodes\n      for (let idx = 0; idx < this.array.length; idx++) {\n        this.updateItem(this.nodess[idx], this.array[idx])\n      }\n      return\n    }\n\n    const parentEl = (this as AnyDLNode)._$parentEl\n    // ---- If the new array is longer, add new nodes directly\n    if (preLength < currLength) {\n      let flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n      // ---- Calling parentEl.childNodes.length is time-consuming,\n      //      so we use a length variable to store the length\n      const length = parentEl.childNodes.length\n      for (let idx = 0; idx < currLength; idx++) {\n        if (idx < preLength) {\n          flowIndex += MutableNode.getFlowIndexFromNodes(this.nodess[idx])\n          this.updateItem(this.nodess[idx], this.array[idx])\n          continue\n        }\n        const newNodes = this.getNewNodes(idx)\n        MutableNode.appendNodesWithIndex(newNodes, parentEl, flowIndex, length)\n        this.nodess.push(newNodes)\n      }\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    // ---- Update the nodes first\n    for (let idx = 0; idx < currLength; idx++) {\n      this.updateItem(this.nodess[idx], this.array[idx])\n    }\n    // ---- If the new array is shorter, remove the extra nodes\n    for (let idx = currLength; idx < preLength; idx++) {\n      this.removeNodes(this.nodess[idx])\n    }\n    this.nodess = this.nodess.slice(0, currLength)\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Update the nodes with keys\n   * @param newArray\n   * @param newKeys\n   */\n  private updateWithKey(newArray: T[], newKeys: G[]): void {\n    const prevKeys = this.keys!\n    const prevArray = this.array\n\n    this.array = [...newArray]\n    this.keys = newKeys\n\n    if (ForNode.arrayEqual(prevKeys, this.keys)) {\n      // ---- If the keys are the same, we only need to update the nodes\n      for (let idx = 0; idx < this.array.length; idx++) {\n        this.updateItem(this.nodess[idx], this.array[idx])\n      }\n      return\n    }\n\n    const parentEl = (this as AnyDLNode)._$parentEl\n    const prevNodess = this.nodess\n\n    // ---- No nodes after, delete all nodes\n    if (this.keys.length === 0) {\n      const parentNodes = parentEl._$nodes ?? []\n      if (parentNodes.length === 1 && parentNodes[0] === this) {\n        // ---- ForNode is the only node in the parent node\n        //      Frequently used in real life scenarios because we tend to always wrap for with a div element,\n        //      so we optimize it here\n        parentEl.innerHTML = \"\"\n      } else {\n        for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\n          this.removeNodes(prevNodess[prevIdx])\n        }\n      }\n      this.nodess = []\n      this._$nodes = []\n      return\n    }\n\n    // ---- Record how many nodes are before this ForNode with the same parentNode\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n\n    // ---- No nodes before, append all nodes\n    if (prevKeys.length === 0) {\n      const nextSibling = parentEl.childNodes[flowIndex]\n      for (let idx = 0; idx < this.keys.length; idx++) {\n        const newNodes = this.getNewNodes(idx)\n        MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n        this.nodess.push(newNodes)\n      }\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    const shuffleKeys: G[] = []\n    const newNodess = []\n    const arrToUpdate = []\n\n    // ---- 1. Delete the nodes that are no longer in the array\n    for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\n      const prevKey = prevKeys[prevIdx]\n      if (this.keys.includes(prevKey)) {\n        shuffleKeys.push(prevKey)\n        newNodess.push(prevNodess[prevIdx])\n        arrToUpdate.push(prevArray[prevIdx])\n        continue\n      }\n      this.removeNodes(prevNodess[prevIdx])\n    }\n\n    // ---- 2. Add the nodes that are not in the array but in the new array\n    // ---- Calling parentEl.childNodes.length is time-consuming,\n    //      so we use a length variable to store the length\n    let length: number = parentEl.childNodes.length\n    let newFlowIndex = flowIndex\n    for (let idx = 0; idx < this.keys.length; idx++) {\n      const key = this.keys[idx]\n      const prevIdx = shuffleKeys.indexOf(key)\n      if (prevIdx !== -1) {\n        // ---- These nodes are already in the parentEl,\n        //      and we need to keep track of their flowIndex\n        newFlowIndex += MutableNode.getFlowIndexFromNodes(newNodess[prevIdx])\n        // ---- Update the nodes\n        this.updateItem(newNodess[prevIdx], this.array[idx])\n        continue\n      }\n      const newNodes = this.getNewNodes(idx)\n      const count = MutableNode.appendNodesWithIndex(\n        newNodes,\n        parentEl,\n        newFlowIndex,\n        length\n      )\n      newFlowIndex += count\n      length += count\n      // ---- Add the new nodes\n      newNodess.splice(idx, 0, newNodes)\n      shuffleKeys.splice(idx, 0, key)\n    }\n\n    // ---- After adding and deleting, the only thing left is to reorder the nodes,\n    //      but if the keys are the same, we don't need to reorder\n    if (ForNode.arrayEqual(this.keys, shuffleKeys)) {\n      this.nodess = newNodess\n      this._$nodes = this.nodess.flat(1)\n      return\n    }\n\n    newFlowIndex = flowIndex\n    const bufferNodes = []\n    // ---- 3. Replace the nodes in the same position using Fisher-Yates shuffle algorithm\n    for (let idx = 0; idx < this.keys.length; idx++) {\n      const key = this.keys[idx]\n      const prevIdx = shuffleKeys.indexOf(key)\n      const bufferedNode = bufferNodes[idx]\n      if (bufferedNode) {\n        // ---- If the node is buffered, we need to add it to the parentEl\n        const addedElNum = MutableNode.appendNodesWithIndex(\n          bufferedNode,\n          parentEl,\n          newFlowIndex + MutableNode.getFlowIndexFromNodes(bufferedNode),\n          length\n        )\n        newFlowIndex += addedElNum\n        length += addedElNum\n        bufferNodes[idx] = undefined\n      } else if (prevIdx === idx) {\n        // ---- If the node is in the same position, we don't need to do anything\n        newFlowIndex += MutableNode.getFlowIndexFromNodes(newNodess[idx])\n        continue\n      } else {\n        // ---- If the node is not in the same position, we need to buffer it\n        bufferNodes[this.keys.indexOf(shuffleKeys[idx])] = newNodess[idx]\n        const addedElNum = MutableNode.appendNodesWithIndex(\n          newNodess[prevIdx],\n          parentEl,\n          newFlowIndex,\n          length\n        )\n        newFlowIndex += addedElNum\n        length += addedElNum\n      }\n      // ---- Swap the nodes\n      const tempNewNodes: AnyDLNode[] = newNodess[idx]\n      newNodess[idx] = newNodess[prevIdx]\n      newNodess[prevIdx] = tempNewNodes\n      const tempKey = shuffleKeys[idx]\n      shuffleKeys[idx] = shuffleKeys[prevIdx]\n      shuffleKeys[prevIdx] = tempKey\n    }\n\n    this.nodess = newNodess\n    this._$nodes = this.nodess.flat(1)\n  }\n\n  /**\n   * @brief Compare two arrays\n   * @param arr1\n   * @param arr2\n   * @returns\n   */\n  private static arrayEqual<T>(arr1: T[], arr2: T[]) {\n    if (arr1.length !== arr2.length) return false\n    return arr1.every((item, idx) => item === arr2[idx])\n  }\n}\n", "import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class ExpNode extends MutableNode {\n  nodesFunc\n\n  /**\n   * @brief Constructor, Exp type, accept a function that returns a list of nodes\n   * @param nodesFunc\n   */\n  constructor(nodesFunc: () => AnyDLNode[]) {\n    super(DLNodeType.Exp)\n    this.nodesFunc = nodesFunc\n    this._$nodes = ExpNode.formatNodes(nodesFunc())\n  }\n\n  /**\n   * @brief Generate new nodes and replace the old nodes\n   */\n  update() {\n    const newNodes = this.geneNewNodesInEnv(() =>\n      ExpNode.formatNodes(this.nodesFunc())\n    )\n    this.removeNodes(this._$nodes!)\n    if (newNodes.length === 0) {\n      this._$nodes = []\n      return\n    }\n\n    // ---- Add new nodes\n    const parentEl = (this as AnyDLNode)._$parentEl\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n    const nextSibling = parentEl.childNodes[flowIndex]\n    MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n\n    this._$nodes = newNodes\n  }\n\n  /**\n   * @brief Format the nodes\n   * @param nodes\n   * @returns New nodes\n   */\n  private static formatNodes(nodes: AnyDLNode | AnyDLNode[]): AnyDLNode[] {\n    if (!Array.isArray(nodes)) nodes = [nodes]\n    return (\n      nodes\n        // ---- Flatten the nodes\n        .flat(1)\n        // ---- Filter out empty nodes\n        .filter(\n          (node: AnyDLNode) =>\n            node !== undefined && node !== null && typeof node !== \"boolean\"\n        )\n        .map((node: any) => {\n          // ---- If the node is a string, number or bigint, convert it to a text node\n          if (\n            typeof node === \"string\" ||\n            typeof node === \"number\" ||\n            typeof node === \"bigint\"\n          ) {\n            return document.createTextNode(`${node}`)\n          }\n          // ---- If the node has PropView, call it to get the view\n          if (\"propViewFunc\" in node) return node.build()\n          return node\n        })\n        // ---- Flatten the nodes again\n        .flat(1)\n    )\n  }\n}\n", "import { type AnyDLNode, DLNodeType } from \"../DLNode\"\nimport { MutableNode } from \"./MutableNode\"\n\nexport class CondNode extends MutableNode {\n  condFunc\n  cond\n  depNum\n\n  /**\n   * @brief Constructor, If type, accept a function that returns a list of nodes\n   * @param caseFunc\n   */\n  constructor(condFunc: (thisCond: CondNode) => AnyDLNode[], depNum: number) {\n    super(DLNodeType.Cond)\n    this.condFunc = condFunc\n    this.depNum = depNum\n    this.cond = -1\n    this._$nodes = this.condFunc(this)\n  }\n\n  /**\n   * @brief Update the nodes in the environment\n   */\n  updateCond(): void {\n    const newNodes = this.geneNewNodesInEnv(() => this.condFunc(this))\n    // ---- If the new nodes are the same as the old nodes, we only need to update  children\n    if ((this as AnyDLNode).didntChange) {\n      ;(this as AnyDLNode).didntChange = false\n      return this.updateChildren()\n    }\n\n    // ---- Remove old nodes\n    this._$nodes && this._$nodes.length > 0 && this.removeNodes(this._$nodes)\n    if (this.cond === -1) {\n      // ---- No branch has been taken\n      this._$nodes = []\n      return\n    }\n    // ---- Add new nodes\n    const parentEl = (this as AnyDLNode)._$parentEl\n    // ---- Faster append with nextSibling rather than flowIndex\n    const flowIndex = MutableNode.getFlowIndexFromNodes(parentEl._$nodes, this)\n\n    const nextSibling = parentEl.childNodes[flowIndex]\n    MutableNode.appendNodesWithSibling(newNodes, parentEl, nextSibling)\n    this._$nodes = newNodes\n  }\n\n  /**\n   * @brief Update the children of IfNode\n   */\n  updateChildren(changed?: number): void {\n    this._$nodes![0]?._$updateFunc?.(changed ?? this.depNum)\n  }\n\n  /**\n   * @brief The update function of IfNode's childNodes is stored in the first child node\n   * @param changed\n   */\n  update(changed: number): void {\n    if (changed & this.depNum) return\n    this.updateChildren(changed)\n  }\n}\n", "import { type AnyDLNode, DLNode, DLNodeType } from \"./DLNode\"\nimport { type CompNode } from \"./CompNode\"\n\ndeclare global {\n  interface Window {\n    DLEnvStore: EnvStoreClass\n  }\n}\n\nclass EnvStoreClass {\n  envs: Record<string, [any, AnyDLNode]> = {}\n  currentEnvNodes: EnvNode[] = []\n  /**\n   * @brief Add a node to the current env and merge envs\n   * @param node\n   */\n  addEnvNode(node: AnyDLNode): void {\n    this.currentEnvNodes.push(node)\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Replace the current env with the given nodes and merge envs\n   * @param nodes\n   */\n  replaceEnvNodes(nodes: AnyDLNode[]): void {\n    this.currentEnvNodes = nodes\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Remove the last node from the current env and merge envs\n   */\n  removeEnvNode(): void {\n    this.currentEnvNodes.pop()\n    this.mergeEnvs()\n  }\n\n  /**\n   * @brief Merge all the envs in currentEnvNodes, inner envs override outer envs\n   */\n  private mergeEnvs(): void {\n    this.envs = {}\n    this.currentEnvNodes.forEach(envNode => {\n      Object.entries(envNode.envs).forEach(([key, value]) => {\n        this.envs[key] = [value, envNode]\n      })\n    })\n  }\n}\n\nif (!window.DLEnvStore) window.DLEnvStore = new EnvStoreClass()\n\nexport class EnvNode extends DLNode {\n  updateNodes = new Set<CompNode>()\n  envs\n\n  /**\n   * @brief Constructor, Env type, accept a record of envs, add this node to DLEnvStore\n   * @param envs\n   */\n  constructor(envs: Record<string, any>) {\n    super(DLNodeType.Env)\n    // ---- Must set this.envs before calling DLEnvStore.addEnvNode,\n    //      because DLEnvStore.addEnvNode will read this.envs and merge it with DLEnvStore.envs\n    this.envs = envs\n    window.DLEnvStore.addEnvNode(this)\n  }\n\n  /**\n   * @brief Update a specific env, and update all the comp nodes that depend on this env\n   * @param name\n   * @param value\n   */\n  updateEnv(name: string, value: any): void {\n    this.envs[name] = value\n    this.updateNodes.forEach(node => {\n      node._$updateEnv(name, value, this)\n    })\n  }\n\n  /**\n   * @brief Add a node to this.updateNodes, delete the node from this.updateNodes when it unmounts\n   * @param node\n   */\n  addNode(node: AnyDLNode): void {\n    this.updateNodes.add(node)\n    DLNode.addWillUnmount(\n      node,\n      this.updateNodes.delete.bind(this.updateNodes, node)\n    )\n  }\n\n  /**\n   * @brief Set this._$nodes, and exit the current env\n   * @param nodes\n   */\n  initNodes(nodes: AnyDLNode[]): void {\n    this._$nodes = nodes\n    window.DLEnvStore.removeEnvNode()\n  }\n}\n", "/**\n * @brief Shorten document.createTextNode\n * @param value\n * @returns Text\n */\nexport function createTextNode(value: string): Text {\n  return document.createTextNode(value)\n}\n\n/**\n * @brief Update text node and check if the value is changed\n * @param node\n * @param value\n */\nexport function updateText(node: Text, value: string): void {\n  if (node.textContent === value) return\n  node.textContent = value\n}\n", "import { DLNode, type AnyDLNode } from \"./DLNode\"\n\nexport class PropView {\n  propViewFunc\n  dlUpdateNodes = new Set<AnyDLNode>()\n\n  /**\n   * @brief PropView constructor, accept a function that returns a list of DLNode\n   * @param propViewFunc\n   */\n  constructor(propViewFunc: () => AnyDLNode[]) {\n    this.propViewFunc = propViewFunc\n  }\n\n  /**\n   * @brief Build the prop view by calling the propViewFunc and add every single instance of the returned DLNode to dlUpdateNodes\n   * @returns the list of DLNode returned by propViewFunc\n   */\n  build(): AnyDLNode[] {\n    const newNodes = this.propViewFunc()\n    if (newNodes.length === 0) return []\n    // ---- The update function is stored in the first node,\n    //      so we push every instance of the first node to dlUpdateNodes\n    const updateNode = newNodes[0]\n    this.dlUpdateNodes.add(updateNode)\n    // ---- Remove the updateNode from dlUpdateNodes when it unmounts\n    DLNode.addWillUnmount(\n      updateNode,\n      this.dlUpdateNodes.delete.bind(this.dlUpdateNodes, updateNode)\n    )\n\n    return newNodes\n  }\n\n  /**\n   * @brief Update every node in dlUpdateNodes\n   * @param changed\n   */\n  update(changed: number): void {\n    this.dlUpdateNodes.forEach(node => {\n      node._$updateFunc?.(changed)\n    })\n  }\n}\n", "import { type AnyDLNode } from \"./DLNode\"\nimport { insertNode } from \"./HTMLNode\"\n\nexport * from \"./HTMLNode\"\nexport * from \"./CompNode\"\nexport * from \"./MutableNode/ForNode\"\nexport * from \"./MutableNode/ExpNode\"\nexport * from \"./MutableNode/CondNode\"\nexport * from \"./EnvNode\"\nexport * from \"./TextNode\"\nexport * from \"./PropView\"\n\nexport function render(idOrEl: string | HTMLElement, DL: AnyDLNode) {\n  let el: HTMLElement = idOrEl as HTMLElement\n  if (typeof idOrEl === \"string\") {\n    const elFound = document.getElementById(idOrEl)\n    if (elFound) el = elFound\n    else {\n      throw new Error(`DLight: Element with id ${idOrEl} not found`)\n    }\n  }\n  el.innerHTML = \"\"\n  const dlNode = new DL()\n  insertNode(el, dlNode, 0)\n}\n\nexport function manual(callback: () => any, _deps?: any[]) {\n  return callback()\n}\nexport function escape<T>(arg: T): T {\n  return arg\n}\n\nexport const $ = escape\n"],
  "mappings": "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",
  "names": ["DLNode", "nodeType", "nodes", "els", "el", "runFunc", "node", "parentEl", "stopNode", "index", "stack", "nextSibling", "length", "count", "currFunc", "prevFunc", "func", "setStyle", "value", "key", "setDataset", "setHTMLProp", "prevKey", "setHTMLProps", "setHTMLAttr", "setHTMLAttrs", "setEvent", "prevEvent", "createTemplate", "templateStr", "template", "element", "createElement", "tag", "insertNode", "position", "forwardHTMLProp", "CompNode", "props", "content", "children", "forwardPropsScope", "envNode", "protoProps", "ownProps", "valueKey", "contentKey", "k", "depNum", "View", "update", "dlNode", "MutableNode", "type", "newNodesFunc", "newNodes", "currentEnvNodes", "ForNode", "array", "nodeFunc", "keys", "item", "changed", "idx", "newArray", "newKeys", "preLength", "currLength", "flowIndex", "prevKeys", "prevArray", "prevNodess", "parentNodes", "prevIdx", "shuffleKeys", "newNodess", "arrToUpdate", "newFlowIndex", "bufferNodes", "bufferedNode", "addedElNum", "tempNewNodes", "tempKey", "arr1", "arr2", "ExpNode", "nodesFunc", "CondNode", "condFunc", "EnvStoreClass", "EnvNode", "envs", "name", "createTextNode", "updateText", "PropView", "propViewFunc", "updateNode", "render", "idOrEl", "DL", "elFound", "manual", "callback", "_deps", "escape", "arg", "$"]
}

{"version":3,"sources":["../src/error.ts","../src/attr.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["import { createErrorHandler } from \"@dlightjs/error-handler\"\n\nexport const DLError = createErrorHandler(\"ReactivityParser\", {\n  1: \"Invalid ViewUnit type\",\n})\n","/**\n * @brief HTML attribute name map, from CamelCase to kebab-case\n */\nexport const alteredAttrMap = {\n  acceptCharset: \"accept-charset\",\n  colSpan: \"colspan\",\n  contentEditable: \"contenteditable\",\n  formAction: \"formaction\",\n  formEnctype: \"formenctype\",\n  formMethod: \"formmethod\",\n  formNoValidate: \"formnovalidate\",\n  formTarget: \"formtarget\",\n  httpEquiv: \"http-equiv\",\n  intrinsicSize: \"intrinsicsize\",\n  inputMode: \"inputmode\",\n  itemProp: \"itemprop\",\n  maxLength: \"maxlength\",\n  minLength: \"minlength\",\n  noValidate: \"novalidate\",\n  playsInline: \"playsinline\",\n  referrerPolicy: \"referrerpolicy\",\n  rowSpan: \"rowspan\",\n  tabIndex: \"tabindex\",\n}\n\n/**\n * @brief Recover HTML attribute name from CamelCase to kebab-case\n * @param name\n * @returns HTML attribute name\n */\nexport function recoverHTMLAttrName(name: string): string {\n  return alteredAttrMap[name as keyof typeof alteredAttrMap] || name\n}\n","import {\n  type TemplateProp,\n  type ReactivityParserConfig,\n  type ReactivityParserOption,\n  type mutableParticle,\n  type ViewParticle,\n  type TemplateParticle,\n  type TextParticle,\n  type HTMLParticle,\n  type DependencyProp,\n  type ExpParticle,\n  type CompParticle,\n  type ForParticle,\n  type IfParticle,\n  type EnvParticle,\n  type SubviewParticle,\n  SwitchParticle,\n} from \"./types\"\nimport { type NodePath, type types as t, type traverse } from \"@babel/core\"\nimport {\n  type TextUnit,\n  type HTMLUnit,\n  type ViewUnit,\n  type CompUnit,\n  type ViewProp,\n  type ForUnit,\n  type IfUnit,\n  type EnvUnit,\n  type ExpUnit,\n  type SubviewUnit,\n  SwitchUnit,\n} from \"@dlightjs/view-parser\"\nimport { DLError } from \"./error\"\nimport { recoverHTMLAttrName } from \"./attr\"\n\nexport class ReactivityParser {\n  private readonly config: ReactivityParserConfig\n  private readonly options?: ReactivityParserOption\n\n  private readonly t: typeof t\n  private readonly traverse: typeof traverse\n  private readonly availableProperties: string[]\n  private readonly dependencyMap: Record<string, string[]>\n  private readonly identifierDepMap: Record<string, string[]>\n  private readonly dependencyParseType\n\n  private readonly escapeNamings = [\"escape\", \"$\"]\n  private readonly customHTMLProps = [\n    \"do\",\n    \"element\",\n    \"innerHTML\",\n    \"prop\",\n    \"attr\",\n    \"dataset\",\n    \"forwardProps\",\n    \"textContent\",\n  ]\n\n  readonly usedProperties = new Set<string>()\n\n  /**\n   * @brief Constructor\n   * @param viewUnit\n   * @param config\n   * @param options\n   */\n  constructor(\n    config: ReactivityParserConfig,\n    options?: ReactivityParserOption\n  ) {\n    this.config = config\n    this.options = options\n    this.t = config.babelApi.types\n    this.traverse = config.babelApi.traverse\n    this.availableProperties = config.availableProperties\n    this.dependencyMap = config.dependencyMap\n    this.identifierDepMap = config.identifierDepMap ?? {}\n    this.dependencyParseType = config.dependencyParseType ?? \"property\"\n    options?.escapeNamings && (this.escapeNamings = options.escapeNamings)\n    options?.customHTMLProps && (this.customHTMLProps = options.customHTMLProps)\n  }\n\n  /**\n   * @brief Parse the ViewUnit into a ViewParticle\n   * @returns\n   */\n  parse(viewUnit: ViewUnit): ViewParticle {\n    return this.parseViewUnit(viewUnit)\n  }\n\n  /**\n   * @brief Parse a ViewUnit into a ViewParticle\n   * @param viewUnit\n   * @returns ViewParticle\n   */\n  private parseViewUnit(viewUnit: ViewUnit): ViewParticle {\n    if (this.isHTMLTemplate(viewUnit))\n      return this.parseTemplate(viewUnit as HTMLUnit)\n    if (viewUnit.type === \"text\") return this.parseText(viewUnit)\n    if (viewUnit.type === \"html\") return this.parseHTML(viewUnit)\n    if (viewUnit.type === \"comp\") return this.parseComp(viewUnit)\n    if (viewUnit.type === \"for\") return this.parseFor(viewUnit)\n    if (viewUnit.type === \"if\") return this.parseIf(viewUnit)\n    if (viewUnit.type === \"env\") return this.parseEnv(viewUnit)\n    if (viewUnit.type === \"exp\") return this.parseExp(viewUnit)\n    if (viewUnit.type === \"switch\") return this.parseSwitch(viewUnit)\n    if (viewUnit.type === \"subview\") return this.parseSubview(viewUnit)\n    return DLError.throw1()\n  }\n\n  // ---- Parsers ----\n  // ---- @Template ----\n  /**\n   * @brief Collect static HTMLUnit into a template particle and generate a template string\n   *  MutableParticle means whatever unit that is not a static HTMLUnit or a TextUnit\n   *  Props means all the non-static props of the nested HTMLUnit or TextUnit, e.g. div().className(this.name)\n   * @param htmlUnit\n   * @returns TemplateParticle\n   */\n  private parseTemplate(htmlUnit: HTMLUnit): TemplateParticle {\n    return {\n      type: \"template\",\n      template: this.generateTemplateString(htmlUnit),\n      props: this.parseTemplateProps(htmlUnit),\n      mutableParticles: this.generateMutableParticles(htmlUnit),\n    }\n  }\n\n  /**\n   * @brief Generate a template string from a static HTMLUnit\n   *  There'll be a situation where the tag is dynamic, e.g. tag(this.htmlTag),\n   *  which we can't generate a template string for it, so we'll wrap it in an ExpParticle in parseHTML() section\n   * @param htmlUnit\n   * @returns template string\n   */\n  private generateTemplateString(htmlUnit: HTMLUnit): string {\n    let templateString = \"\"\n    const generateString = (unit: HTMLUnit) => {\n      const tagName = (unit.tag as t.StringLiteral).value\n      const staticProps = this.filterTemplateProps(\n        // ---- Get all the static props\n        Object.entries(unit.props ?? [])\n          .filter(\n            ([, prop]) =>\n              this.isStaticProp(prop) &&\n              // ---- Filter out props with false values\n              !(this.t.isBooleanLiteral(prop.value) && !prop.value.value)\n          )\n          .map<[string, string | boolean]>(([key, { value }]) => [\n            recoverHTMLAttrName(key),\n            (value as t.StringLiteral).value,\n          ])\n      )\n\n      // ---- Open tag with props\n      const propString = staticProps\n        .map(([key, value]) =>\n          value === true ? ` ${key}` : ` ${key}=\"${value}\"`\n        )\n        .join(\"\")\n      templateString += `<${tagName}${propString}>`\n\n      // ---- ChildParticles\n      if (unit.content) {\n        // ---- Attach the content of current tag if it's a static string\n        if (this.isStaticProp(unit.content)) {\n          templateString += (unit.content.value as t.StringLiteral).value\n        }\n      } else {\n        unit.children?.forEach(unit => {\n          // ---- Recursively generate child particles\n          if (unit.type === \"html\" && this.t.isStringLiteral(unit.tag)) {\n            generateString(unit)\n            return\n          }\n          // ---- Attach the text content to the parent tag\n          if (unit.type === \"text\" && this.t.isStringLiteral(unit.content)) {\n            templateString += unit.content.value\n          }\n        })\n      }\n\n      // ---- Close tag\n      templateString += `</${tagName}>`\n    }\n    generateString(htmlUnit)\n\n    return templateString\n  }\n\n  /**\n   * @brief Collect all the mutable nodes in a static HTMLUnit\n   *  We use this function to collect mutable nodes' path and props,\n   *  so that in the generator, we know which position to insert the mutable nodes\n   * @param htmlUnit\n   * @returns mutable particles\n   */\n  private generateMutableParticles(htmlUnit: HTMLUnit): mutableParticle[] {\n    const mutableParticles: mutableParticle[] = []\n    const generateMutableUnit = (unit: HTMLUnit, path: number[] = []) => {\n      // ---- Generate mutable particles for current HTMLUnit\n      unit.children?.forEach((child, idx) => {\n        if (\n          !(child.type === \"html\" && this.t.isStringLiteral(child.tag)) &&\n          !(child.type === \"text\" && this.t.isStringLiteral(child.content))\n        ) {\n          mutableParticles.push({\n            path: [...path, idx],\n            ...this.parseViewParticle(child),\n          })\n        }\n      })\n      // ---- Recursively generate mutable particles for static HTMLUnit children\n      unit.children\n        ?.filter(\n          child => child.type === \"html\" && this.t.isStringLiteral(child.tag)\n        )\n        .forEach((child, idx) => {\n          generateMutableUnit(child as HTMLUnit, [...path, idx])\n        })\n    }\n    generateMutableUnit(htmlUnit)\n\n    return mutableParticles\n  }\n\n  /**\n   * @brief Collect all the props in a static HTMLUnit or its nested HTMLUnit or TextUnit children\n   *  Just like the mutable nodes, props are also equipped with path,\n   *  so that we know which HTML ChildNode to insert the props\n   * @param htmlUnit\n   * @returns props\n   */\n  private parseTemplateProps(htmlUnit: HTMLUnit): TemplateProp[] {\n    const templateProps: TemplateProp[] = []\n    const generateVariableProp = (unit: HTMLUnit, path: number[]) => {\n      // ---- Generate all non-static(string/number/boolean) props for current HTMLUnit\n      //      to be inserted further in the generator\n      Object.entries({\n        ...(unit.props ?? {}),\n        ...(unit.content ? { textContent: unit.content } : {}),\n      })\n        .filter(([, prop]) => !this.isStaticProp(prop))\n        .forEach(([key, prop]) => {\n          const dependencyIndexArr = this.getDependencies(prop.value)\n          templateProps.push({\n            tag: (unit.tag as t.StringLiteral).value,\n            key,\n            path,\n            value: prop.value,\n            dependencyIndexArr,\n          })\n        })\n      // ---- Recursively generate props for static HTMLUnit children\n      unit.children\n        ?.filter(\n          child =>\n            (child.type === \"html\" && this.t.isStringLiteral(child.tag)) ||\n            (child.type === \"text\" && this.t.isStringLiteral(child.content))\n        )\n        .forEach((child, idx) => {\n          if (child.type === \"html\") {\n            generateVariableProp(child, [...path, idx])\n          } else if (child.type === \"text\") {\n            // ---- if the child is a TextUnit, we just insert the text content\n            templateProps.push({\n              tag: \"text\",\n              key: \"value\",\n              path: [...path, idx],\n              value: child.content,\n            })\n          }\n        })\n    }\n    generateVariableProp(htmlUnit, [])\n\n    return templateProps\n  }\n\n  // ---- @Text ----\n  /**\n   * @brief Parse a TextUnit into a TextParticle.\n   *  This is only for a top level TextUnit, because if nested in HTMLUnit, it'll be parsed in the template string\n   * @param textUnit\n   * @returns TextParticle\n   */\n  private parseText(textUnit: TextUnit): TextParticle {\n    return {\n      type: \"text\",\n      content: {\n        value: textUnit.content,\n        dependencyIndexArr: this.getDependencies(textUnit.content),\n      },\n    }\n  }\n\n  // ---- @HTML ----\n  /**\n   * @brief Parse an HTMLUnit with a dynamic tag into an ExpParticle or an HTMLParticle\n   *  We detect dependencies in the tag, if there's no dependency,\n   *  we parse it as an HTMLParticle and dynamically append it to the parent node;\n   *  if there's dependency, we parse it as an ExpParticle and wrap it in an ExpParticle\n   *  so that we can make the tag reactive\n   * @param htmlUnit\n   * @returns ExpParticle | HTMLParticle\n   */\n  private parseHTML(htmlUnit: HTMLUnit): ExpParticle | HTMLParticle {\n    const tagDependencies = this.getDependencies(htmlUnit.tag)\n\n    const innerHTMLParticle: HTMLParticle = {\n      type: \"html\",\n      tag: htmlUnit.tag,\n    }\n\n    if (htmlUnit.props) {\n      if (htmlUnit.content) {\n        htmlUnit.props.textContent = htmlUnit.content\n      }\n      innerHTMLParticle.props = Object.fromEntries(\n        Object.entries(htmlUnit.props).map(([key, prop]) => [\n          key,\n          this.generateDependencyProp(prop),\n        ])\n      )\n    }\n    if (htmlUnit.children) {\n      innerHTMLParticle.children = htmlUnit.children.map(\n        this.parseViewParticle.bind(this)\n      )\n    }\n\n    // ---- Not a dynamic tag\n    if (tagDependencies.length === 0) return innerHTMLParticle\n\n    // ---- Dynamic tag, wrap it in an ExpParticle to make the tag reactive\n    const id = this.uid()\n    return {\n      type: \"exp\",\n      content: {\n        value: this.t.stringLiteral(id),\n        viewPropMap: {\n          [id]: [innerHTMLParticle],\n        },\n        dependencyIndexArr: tagDependencies,\n      },\n    }\n  }\n\n  // ---- @Comp ----\n  /**\n   * @brief Parse a CompUnit into a CompParticle or an ExpParticle\n   *  Similar to parseHTML(), we detect dependencies in the tag, if there's no dependency,\n   *  we parse it as a regular CompParticle, otherwise we wrap it with an ExpParticle.\n   * @param compUnit\n   * @returns CompParticle | ExpParticle\n   */\n  private parseComp(compUnit: CompUnit): CompParticle | ExpParticle {\n    const tagDependencies = this.getDependencies(compUnit.tag)\n\n    const compParticle: CompParticle = {\n      type: \"comp\",\n      tag: compUnit.tag,\n    }\n\n    if (compUnit.content) {\n      compParticle.content = this.generateDependencyProp(compUnit.content)\n    }\n    if (compUnit.props) {\n      compParticle.props = Object.fromEntries(\n        Object.entries(compUnit.props).map(([key, prop]) => [\n          key,\n          this.generateDependencyProp(prop),\n        ])\n      )\n    }\n    if (compUnit.children) {\n      compParticle.children = compUnit.children.map(\n        this.parseViewParticle.bind(this)\n      )\n    }\n\n    if (tagDependencies.length === 0) return compParticle\n\n    const id = this.uid()\n    return {\n      type: \"exp\",\n      content: {\n        value: this.t.stringLiteral(id),\n        viewPropMap: {\n          [id]: [compParticle],\n        },\n        dependencyIndexArr: tagDependencies,\n      },\n    }\n  }\n\n  // ---- @For ----\n  /**\n   * @brief Parse a ForUnit into a ForParticle with dependencies\n   *  Key and item doesn't need to be reactive, so here we don't collect dependencies for it\n   * @param forUnit\n   * @returns ForParticle\n   */\n  private parseFor(forUnit: ForUnit): ForParticle {\n    const dependencyIndexArr = this.getDependencies(forUnit.array)\n    const prevIdentifierDepMap = this.config.identifierDepMap\n    // ---- Find all the identifiers in the key and remove them from the identifierDepMap\n    //      because once the key is changed, that identifier related dependencies will be changed too,\n    //      so no need to update them\n    const keyDep = this.t.isIdentifier(forUnit.key) && forUnit.key.name\n    // ---- Generate an identifierDepMap to track identifiers in item and make them reactive\n    //      based on the dependencies from the array\n    this.config.identifierDepMap = Object.fromEntries(\n      this.getIdentifiers(\n        this.t.assignmentExpression(\n          \"=\",\n          forUnit.item,\n          this.t.identifier(\"temp\")\n        )\n      )\n        .filter(id => !keyDep || id !== keyDep)\n        .map(id => [\n          id,\n          dependencyIndexArr.map(n => this.availableProperties[n]),\n        ])\n    )\n    const forParticle: ForParticle = {\n      type: \"for\",\n      item: forUnit.item,\n      array: {\n        value: forUnit.array,\n        dependencyIndexArr,\n      },\n      children: forUnit.children.map(this.parseViewParticle.bind(this)),\n      key: forUnit.key,\n    }\n    this.config.identifierDepMap = prevIdentifierDepMap\n    return forParticle\n  }\n\n  // ---- @If ----\n  /**\n   * @brief Parse an IfUnit into an IfParticle with dependencies\n   * @param ifUnit\n   * @returns IfParticle\n   */\n  private parseIf(ifUnit: IfUnit): IfParticle {\n    return {\n      type: \"if\",\n      branches: ifUnit.branches.map(branch => ({\n        condition: {\n          value: branch.condition,\n          dependencyIndexArr: this.getDependencies(branch.condition),\n        },\n        children: branch.children.map(this.parseViewParticle.bind(this)),\n      })),\n    }\n  }\n\n  // ---- @Switch ----\n  /**\n   * @brief Parse a SwitchUnit into an SwitchParticle with dependencies\n   * @param switchUnit\n   * @returns SwitchParticle\n   */\n  private parseSwitch(switchUnit: SwitchUnit): SwitchParticle {\n    return {\n      type: \"switch\",\n      discriminant: {\n        value: switchUnit.discriminant,\n        dependencyIndexArr: this.getDependencies(switchUnit.discriminant),\n      },\n      branches: switchUnit.branches.map(branch => ({\n        case: branch.case\n          ? {\n              value: branch.case,\n              dependencyIndexArr: this.getDependencies(branch.case),\n            }\n          : null,\n        children: branch.children.map(this.parseViewParticle.bind(this)),\n        break: branch.break,\n      })),\n    }\n  }\n\n  // ---- @Env ----\n  /**\n   * @brief Parse an EnvUnit into an EnvParticle with dependencies\n   * @param envUnit\n   * @returns EnvParticle\n   */\n  private parseEnv(envUnit: EnvUnit): EnvParticle {\n    return {\n      type: \"env\",\n      props: Object.fromEntries(\n        Object.entries(envUnit.props).map(([key, prop]) => [\n          key,\n          this.generateDependencyProp(prop),\n        ])\n      ),\n      children: envUnit.children.map(this.parseViewParticle.bind(this)),\n    }\n  }\n\n  // ---- @Exp ----\n  /**\n   * @brief Parse an ExpUnit into an ExpParticle with dependencies\n   * @param expUnit\n   * @returns ExpParticle\n   */\n  private parseExp(expUnit: ExpUnit): ExpParticle {\n    const expParticle: ExpParticle = {\n      type: \"exp\",\n      content: this.generateDependencyProp(expUnit.content),\n    }\n    if (expUnit.props) {\n      expParticle.props = Object.fromEntries(\n        Object.entries(expUnit.props).map(([key, prop]) => [\n          key,\n          this.generateDependencyProp(prop),\n        ])\n      )\n    }\n    return expParticle\n  }\n\n  // ---- @Subview ----\n  /**\n   * @brief Parse a SubviewUnit into a SubviewParticle with dependencies\n   * @param subviewUnit\n   * @returns SubviewParticle\n   */\n  private parseSubview(subviewUnit: SubviewUnit): SubviewParticle {\n    const subviewParticle: SubviewParticle = {\n      type: \"subview\",\n      tag: subviewUnit.tag,\n    }\n    if (subviewUnit.props) {\n      subviewParticle.props = Object.fromEntries(\n        Object.entries(subviewUnit.props).map(([key, prop]) => [\n          key,\n          this.generateDependencyProp(prop),\n        ])\n      )\n    }\n    if (subviewUnit.children) {\n      subviewParticle.children = subviewUnit.children.map(\n        this.parseViewParticle.bind(this)\n      )\n    }\n\n    return subviewParticle\n  }\n\n  // ---- Dependencies ----\n  /**\n   * @brief Generate a dependency prop with dependencies\n   * @param prop\n   * @returns DependencyProp\n   */\n  private generateDependencyProp(prop: ViewProp): DependencyProp {\n    const dependencyProp: DependencyProp = {\n      value: prop.value,\n      dependencyIndexArr: this.getDependencies(prop.value),\n    }\n    if (prop.viewPropMap) {\n      dependencyProp.viewPropMap = Object.fromEntries(\n        Object.entries(prop.viewPropMap).map(([key, units]) => [\n          key,\n          units.map(this.parseViewParticle.bind(this)),\n        ])\n      )\n    }\n    return dependencyProp\n  }\n\n  /**\n   * @brief Get all the dependencies of a node\n   *  this.dependencyParseType controls how we parse the dependencies\n   * 1. property: parse the dependencies of a node as a property, e.g. this.name\n   * 2. identifier: parse the dependencies of a node as an identifier, e.g. name\n   * The availableProperties is the list of all the properties that can be used in the template,\n   * no matter it's a property or an identifier\n   * @param node\n   * @returns dependency index array\n   */\n  private getDependencies(node: t.Expression | t.Statement): number[] {\n    const directDependencies =\n      this.dependencyParseType === \"identifier\"\n        ? this.getIdentifierDependencies(node)\n        : this.getPropertyDependencies(node)\n\n    return [\n      ...new Set([\n        ...directDependencies,\n        ...this.getIdentifierMapDependencies(node),\n      ]),\n    ]\n  }\n\n  /**\n   * @brief Get all the dependencies of a node if a property is a valid dependency as\n   *  1. the identifier is in the availableProperties\n   *  2. the identifier is a stand alone identifier\n   *  3. the identifier is not in an escape function\n   *  4. the identifier is not in a manual function\n   *  5. the identifier is not the left side of an assignment expression, which is an assignment expression\n   *  6. the identifier is not the right side of an assignment expression, which is an update expression\n   * @param node\n   * @returns dependency index array\n   */\n  private getIdentifierDependencies(\n    node: t.Expression | t.Statement\n  ): number[] {\n    const deps = new Set<string>()\n\n    const wrappedNode = this.valueWrapper(node)\n    this.traverse(wrappedNode, {\n      Identifier: innerPath => {\n        const identifier = innerPath.node\n        const idName = identifier.name\n        if (\n          this.availableProperties.includes(idName) &&\n          this.isStandAloneIdentifier(innerPath) &&\n          !this.isMemberInEscapeFunction(innerPath) &&\n          !this.isMemberInManualFunction(innerPath) &&\n          !this.isAssignmentExpressionLeft(innerPath) &&\n          !this.isAssignmentIdentifierExpressionRight(innerPath)\n        ) {\n          deps.add(idName)\n          this.dependencyMap[idName]?.forEach(deps.add.bind(deps))\n        }\n      },\n    })\n\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties))\n    return [...deps].map(dep => this.availableProperties.indexOf(dep))\n  }\n\n  /**\n   * @brief Get all the dependencies of a node if a member expression is a valid dependency as\n   *  1. the property is in the availableProperties\n   *  2. the object is this\n   *  3. the member expression is not in an escape function\n   *  4. the member expression is not in a manual function\n   *  5. the member expression is not the left side of an assignment expression, which is an assignment expression\n   *  6. the member expression is not the right side of an assignment expression, which is an update expression\n   * @param node\n   * @returns dependency index array\n   */\n  private getPropertyDependencies(node: t.Expression | t.Statement): number[] {\n    const deps = new Set<string>()\n\n    const wrappedNode = this.valueWrapper(node)\n    this.traverse(wrappedNode, {\n      MemberExpression: innerPath => {\n        if (!this.t.isIdentifier(innerPath.node.property)) return\n        const propertyKey = innerPath.node.property.name\n        if (\n          this.availableProperties.includes(propertyKey) &&\n          this.t.isThisExpression(innerPath.node.object) &&\n          !this.isMemberInEscapeFunction(innerPath) &&\n          !this.isMemberInManualFunction(innerPath) &&\n          !this.isAssignmentExpressionLeft(innerPath) &&\n          !this.isAssignmentPropertyExpressionRight(innerPath)\n        ) {\n          deps.add(propertyKey)\n          this.dependencyMap[propertyKey]?.forEach(deps.add.bind(deps))\n        }\n      },\n    })\n\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties))\n    return [...deps].map(dep => this.availableProperties.indexOf(dep))\n  }\n\n  /**\n   * @brief Get dependencies from the identifierDepMap\n   *  e.g.\n   *  map: { \"a\": [\"dep1\", \"dep2\"] }\n   *  expression: const b = a\n   *  deps for b: [\"dep1\", \"dep2\"]\n   * @param node\n   * @returns dependency index array\n   */\n  private getIdentifierMapDependencies(\n    node: t.Expression | t.Statement\n  ): number[] {\n    const deps = new Set<string>()\n\n    const wrappedNode = this.valueWrapper(node)\n    this.traverse(wrappedNode, {\n      Identifier: innerPath => {\n        const identifier = innerPath.node\n        const idName = identifier.name\n        if (this.isAttrFromFunction(innerPath, idName)) return\n        const depsArray = this.identifierDepMap[idName]\n\n        if (!depsArray) return\n        if (\n          this.isMemberInEscapeFunction(innerPath) ||\n          this.isMemberInManualFunction(innerPath)\n        )\n          return\n        depsArray.forEach(deps.add.bind(deps))\n      },\n    })\n\n    deps.forEach(this.usedProperties.add.bind(this.usedProperties))\n    return [...deps].map(dep => this.availableProperties.indexOf(dep))\n  }\n\n  // ---- Utils ----\n  /**\n   * @brief Parse a ViewUnit into a ViewParticle by new-ing a ReactivityParser\n   * @param viewUnit\n   * @returns ViewParticle\n   */\n  private parseViewParticle(viewUnit: ViewUnit): ViewParticle {\n    const parser = new ReactivityParser(this.config, this.options)\n    const parsedUnit = parser.parse(viewUnit)\n    // ---- Collect used properties\n    parser.usedProperties.forEach(\n      this.usedProperties.add.bind(this.usedProperties)\n    )\n    return parsedUnit\n  }\n\n  /**\n   * @brief Check if a ViewUnit is a static HTMLUnit that can be parsed into a template\n   *  Must satisfy:\n   *  1. type is html\n   *  2. tag is a string literal, i.e., non-dynamic tag\n   *  3. has at least one child that is a static HTMLUnit,\n   *     or else just call a createElement function, no need for template clone\n   * @param viewUnit\n   * @returns is a static HTMLUnit\n   */\n  private isHTMLTemplate(viewUnit: ViewUnit): boolean {\n    return (\n      viewUnit.type === \"html\" &&\n      this.t.isStringLiteral(viewUnit.tag) &&\n      !!viewUnit.children?.some(\n        child => child.type === \"html\" && this.t.isStringLiteral(child.tag)\n      )\n    )\n  }\n\n  /**\n   * @brief Check if a prop is a static prop\n   *  i.e.\n   *  1. no viewPropMap\n   *  2. value is a string/number/boolean literal\n   * @param prop\n   * @returns is a static prop\n   */\n  private isStaticProp(prop: ViewProp): boolean {\n    const { value, viewPropMap } = prop\n    return (\n      (!viewPropMap || Object.keys(viewPropMap).length === 0) &&\n      (this.t.isStringLiteral(value) ||\n        this.t.isNumericLiteral(value) ||\n        this.t.isBooleanLiteral(value))\n    )\n  }\n\n  /**\n   * @brief Filter out some props that are not needed in the template,\n   *  these are all special props to be parsed differently in the generator\n   * @param props\n   * @returns filtered props\n   */\n  private filterTemplateProps<T>(\n    props: Array<[string, T]>\n  ): Array<[string, T]> {\n    return (\n      props\n        // ---- Filter out event listeners\n        .filter(([key]) => !key.startsWith(\"on\"))\n        // ---- Filter out specific props\n        .filter(([key]) => !this.customHTMLProps.includes(key))\n    )\n  }\n\n  /**\n   * @brief Wrap the value in a file\n   * @param node\n   * @returns wrapped value\n   */\n  private valueWrapper(node: t.Expression | t.Statement): t.File {\n    return this.t.file(\n      this.t.program([\n        this.t.isStatement(node) ? node : this.t.expressionStatement(node),\n      ])\n    )\n  }\n\n  /**\n   * @brief Check if an identifier is a simple stand alone identifier,\n   *  i.e., not a member expression, nor a function param\n   * @param path\n   *  1. not a member expression\n   *  2. not a function param\n   *  3. not in a declaration\n   *  4. not as object property's not computed key\n   * @returns is a stand alone identifier\n   */\n  private isStandAloneIdentifier(path: NodePath<t.Identifier>): boolean {\n    const node = path.node\n    const parentNode = path.parentPath?.node\n    const isMemberExpression =\n      this.t.isMemberExpression(parentNode) && parentNode.property === node\n    if (isMemberExpression) return false\n    const isFunctionParam = this.isAttrFromFunction(path, node.name)\n    if (isFunctionParam) return false\n    while (path.parentPath) {\n      if (this.t.isVariableDeclarator(path.parentPath.node)) return false\n      if (\n        this.t.isObjectProperty(path.parentPath.node) &&\n        path.parentPath.node.key === path.node &&\n        !path.parentPath.node.computed\n      )\n        return false\n      path = path.parentPath as NodePath<t.Identifier>\n    }\n    return true\n  }\n\n  /**\n   * @brief Get all identifiers as strings in a node\n   * @param node\n   * @returns identifiers\n   */\n  private getIdentifiers(node: t.Node): string[] {\n    if (this.t.isIdentifier(node)) return [node.name]\n    const identifierKeys = new Set<string>()\n    this.traverse(this.valueWrapper(node as t.Expression), {\n      Identifier: innerPath => {\n        if (!this.isStandAloneIdentifier(innerPath)) return\n        identifierKeys.add(innerPath.node.name)\n      },\n    })\n    return [...identifierKeys]\n  }\n\n  /**\n   * @brief check if the identifier is from a function param till the stopNode\n   *  e.g:\n   *  function myFunc1(ok) { // stopNode = functionBody\n   *     const myFunc2 = ok => ok // from function param\n   *     console.log(ok) // not from function param\n   *  }\n   */\n  private isAttrFromFunction(path: NodePath, idName: string) {\n    let reversePath = path.parentPath\n\n    const checkParam: (param: t.Node) => boolean = (param: t.Node) => {\n      // ---- 3 general types:\n      //      * represent allow nesting\n      // ---0 Identifier: (a)\n      // ---1 RestElement: (...a)   *\n      // ---1 Pattern: 3 sub Pattern\n      // -----0   AssignmentPattern: (a=1)   *\n      // -----1   ArrayPattern: ([a, b])   *\n      // -----2   ObjectPattern: ({a, b})\n      if (this.t.isIdentifier(param)) return param.name === idName\n      if (this.t.isAssignmentPattern(param)) return checkParam(param.left)\n      if (this.t.isArrayPattern(param)) {\n        return param.elements\n          .filter(Boolean)\n          .map(el => checkParam(el!))\n          .includes(true)\n      }\n      if (this.t.isObjectPattern(param)) {\n        return (\n          param.properties.filter(\n            prop =>\n              this.t.isObjectProperty(prop) && this.t.isIdentifier(prop.key)\n          ) as t.ObjectProperty[]\n        )\n          .map(prop => (prop.key as t.Identifier).name)\n          .includes(idName)\n      }\n      if (this.t.isRestElement(param)) return checkParam(param.argument)\n\n      return false\n    }\n\n    while (reversePath) {\n      const node = reversePath.node\n      if (\n        this.t.isArrowFunctionExpression(node) ||\n        this.t.isFunctionDeclaration(node)\n      ) {\n        for (const param of node.params) {\n          if (checkParam(param)) return true\n        }\n      }\n      reversePath = reversePath.parentPath\n    }\n\n    return false\n  }\n\n  /**\n   * @brief Check if it's the left side of an assignment expression, e.g. this.count = 1\n   * @param innerPath\n   * @returns is left side of an assignment expression\n   */\n  private isAssignmentExpressionLeft(innerPath: NodePath): boolean {\n    const parentNode = innerPath.parentPath?.node\n\n    return (\n      (this.t.isAssignmentExpression(parentNode) &&\n        parentNode.left === innerPath.node) ||\n      this.t.isUpdateExpression(parentNode)\n    )\n  }\n\n  /**\n   * @brief Check if a member expression is the right side of an assignment expression\n   *   e.g. this.count = this.count + 1\n   * @param innerPath\n   * @returns is the right side of an assignment expression\n   */\n  private isAssignmentPropertyExpressionRight(\n    innerPath: NodePath<t.MemberExpression>\n  ): boolean {\n    const currNode = innerPath.node\n\n    let isRightExp = false\n    let reversePath: NodePath<t.Node> | null = innerPath.parentPath\n    while (reversePath) {\n      if (this.t.isAssignmentExpression(reversePath.node)) {\n        const leftNode = reversePath.node.left as t.MemberExpression\n        const typeEqual = currNode.type === leftNode.type\n        const identifierEqual =\n          (currNode.property as t.Identifier).name ===\n          (leftNode.property as t.Identifier).name\n        isRightExp = typeEqual && identifierEqual\n      }\n      reversePath = reversePath.parentPath\n    }\n\n    return isRightExp\n  }\n\n  /**\n   * @brief Check if an identifier is the right side of an assignment expression\n   *   e.g. count = count + 1\n   * @param innerPath\n   * @returns is the right side of an assignment expression\n   */\n  private isAssignmentIdentifierExpressionRight(\n    innerPath: NodePath<t.Identifier>\n  ): boolean {\n    const currNode = innerPath.node\n\n    let isRightExp = false\n    let reversePath: NodePath<t.Node> | null = innerPath.parentPath\n    while (reversePath) {\n      if (this.t.isAssignmentExpression(reversePath.node)) {\n        const leftNode = reversePath.node.left as t.Identifier\n        const typeEqual = currNode.type === leftNode.type\n        const identifierEqual = currNode.name === leftNode.name\n        isRightExp = typeEqual && identifierEqual\n      }\n      reversePath = reversePath.parentPath\n    }\n\n    return isRightExp\n  }\n\n  /**\n   * @brief Check if it's in an \"escape\" function,\n   *        e.g. escape(() => { console.log(this.count) })\n   *              deps will be empty instead of [\"count\"]\n   * @param innerPath\n   * @param classDeclarationNode\n   * @returns is in escape function\n   */\n  private isMemberInEscapeFunction(innerPath: NodePath): boolean {\n    let isInFunction = false\n    let reversePath = innerPath.parentPath\n    while (reversePath) {\n      const node = reversePath.node\n      if (\n        this.t.isCallExpression(node) &&\n        this.t.isIdentifier(node.callee) &&\n        this.escapeNamings.includes(node.callee.name)\n      ) {\n        isInFunction = true\n        break\n      }\n      reversePath = reversePath.parentPath\n    }\n    return isInFunction\n  }\n\n  /**\n   * @brief Check if it's in a \"manual\" function,\n   *        e.g. manual(() => { console.log(this.count) }, [\"flag\"])\n   *             deps will be [\"flag\"] instead of [\"count\"]\n   * @param innerPath\n   * @param classDeclarationNode\n   * @returns is in manual function\n   */\n  private isMemberInManualFunction(innerPath: NodePath): boolean {\n    let isInFunction = false\n    let reversePath = innerPath.parentPath\n\n    while (reversePath) {\n      const node = reversePath.node\n      const parentNode = reversePath.parentPath?.node\n      const isManual =\n        this.t.isCallExpression(parentNode) &&\n        this.t.isIdentifier(parentNode.callee) &&\n        parentNode.callee.name === \"manual\"\n      const isFirstParam =\n        this.t.isCallExpression(parentNode) && parentNode.arguments[0] === node\n      if (isManual && isFirstParam) {\n        isInFunction = true\n        break\n      }\n      reversePath = reversePath.parentPath\n    }\n\n    return isInFunction\n  }\n\n  /**\n   * @brief Generate a random string\n   * @returns\n   */\n  private uid(): string {\n    return Math.random().toString(36).slice(2)\n  }\n}\n","import { type ViewUnit } from \"@dlightjs/view-parser\"\nimport { ReactivityParser } from \"./parser\"\nimport {\n  type ViewParticle,\n  type ReactivityParserConfig,\n  type ReactivityParserOption,\n} from \"./types\"\n\n/**\n * @brief Parse view units to get used properties and view particles with reactivity\n * @param viewUnits\n * @param config\n * @param options\n * @returns [viewParticles, usedProperties]\n */\nexport function parseReactivity(\n  viewUnits: ViewUnit[],\n  config: ReactivityParserConfig,\n  options?: ReactivityParserOption\n): [ViewParticle[], Set<string>] {\n  // ---- ReactivityParser only accepts one view unit at a time,\n  //      so we loop through the view units and get all the used properties\n  const usedProperties = new Set<string>()\n  const dlParticles = viewUnits.map(viewUnit => {\n    const parser = new ReactivityParser(config, options)\n    const dlParticle = parser.parse(viewUnit)\n    parser.usedProperties.forEach(usedProperties.add.bind(usedProperties))\n    return dlParticle\n  })\n  return [dlParticles, usedProperties]\n}\n\nexport type * from \"./types\"\n"],"mappings":"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","names":["createErrorHandler","DLError","alteredAttrMap","recoverHTMLAttrName","name","ReactivityParser","config","options","viewUnit","DLError","htmlUnit","templateString","generateString","unit","tagName","propString","prop","key","value","recoverHTMLAttrName","mutableParticles","generateMutableUnit","path","child","idx","templateProps","generateVariableProp","dependencyIndexArr","textUnit","tagDependencies","innerHTMLParticle","id","compUnit","compParticle","forUnit","prevIdentifierDepMap","keyDep","n","forParticle","ifUnit","branch","switchUnit","envUnit","expUnit","expParticle","subviewUnit","subviewParticle","dependencyProp","units","node","directDependencies","deps","wrappedNode","innerPath","idName","dep","propertyKey","depsArray","parser","parsedUnit","viewPropMap","props","parentNode","identifierKeys","reversePath","checkParam","param","el","currNode","isRightExp","leftNode","typeEqual","identifierEqual","isInFunction","isManual","isFirstParam","parseReactivity","viewUnits","config","options","usedProperties","viewUnit","parser","ReactivityParser","dlParticle"]}
type AnyDLNode = any;
declare enum DLNodeType {
    Comp = 0,
    For = 1,
    Cond = 2,
    Env = 3,
    Exp = 4,
    Subview = 5
}
declare class DLNode {
    /**
     * @brief Node type: HTML, Text, Custom, For, If, Env, Expression
     */
    _$dlNodeType: DLNodeType;
    /**
     * @brief Constructor
     * @param nodeType
     */
    constructor(nodeType: DLNodeType);
    /**
     * @brief Node element
     *  Either one real element for HTMLNode and TextNode
     *  Or an array of DLNode for CustomNode, ForNode, IfNode, EnvNode, ExpNode
     */
    get _$el(): HTMLElement[];
    /**
     * @brief Parent dom element, will be passed to child nodes
     */
    _$parentEl?: HTMLElement;
    /**
     * @brief Child DLNodes
     */
    _$nodes?: AnyDLNode[];
    /**
     * @brief Loop all child DLNodes to get all the child elements
     * @param nodes
     * @returns HTMLElement[]
     */
    private static toEls;
    /**
     * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes
     * @param nodes
     * @param runFunc
     */
    static loopDLNodes(nodes: AnyDLNode[], runFunc: (node: AnyDLNode) => void): void;
    /**
     * @brief Loop all child DLNodes deeply, including all the child nodes of child nodes
     * @param nodes
     * @param runFunc
     */
    static loopDLNodesInsideOut(nodes: AnyDLNode[], runFunc: (node: AnyDLNode) => void): void;
    /**
     * @brief Loop all elements shallowly,
     *  i.e., don't loop the child nodes of dom elements and only call runFunc on dom elements
     * @param nodes
     * @param runFunc
     */
    static loopShallowEls(nodes: AnyDLNode[], runFunc: (node: AnyDLNode) => void): void;
    /**
     * @brief Loop all nodes shallowly,
     *  i.e., don't loop the child nodes of dom elements and call runFunc on all nodes
     * @param nodes
     * @param runFunc
     */
    static loopShallowDLNodes(nodes: any[], runFunc: (node: any) => void): void;
    /**
     * @brief Add parentEl to all nodes until the first element
     * @param nodes
     * @param parentEl
     */
    static addParentEl(nodes: AnyDLNode[], parentEl: HTMLElement): void;
    /**
     * @brief Get the total count of dom elements before the stop node
     * @param nodes
     * @param stopNode
     * @returns total count of dom elements
     */
    static getFlowIndexFromNodes(nodes: AnyDLNode[], stopNode?: AnyDLNode): number;
    /**
     * @brief Given an array of nodes, append them to the parentEl
     *  1. If nextSibling is provided, insert the nodes before the nextSibling
     *  2. If nextSibling is not provided, append the nodes to the parentEl
     * @param nodes
     * @param parentEl
     * @param nextSibling
     * @returns Added element count
     */
    static appendNodesWithSibling(nodes: AnyDLNode[], parentEl: HTMLElement, nextSibling: HTMLElement | undefined): number;
    /**
     * @brief Given an array of nodes, append them to the parentEl using the index
     *  1. If the index is the same as the length of the parentEl.childNodes, append the nodes to the parentEl
     *  2. If the index is not the same as the length of the parentEl.childNodes, insert the nodes before the node at the index
     * @param nodes
     * @param parentEl
     * @param index
     * @param length
     * @returns Added element count
     */
    static appendNodesWithIndex(nodes: AnyDLNode[], parentEl: HTMLElement, index: number, length?: number): number;
    /**
     * @brief Insert nodes before the nextSibling
     * @param nodes
     * @param parentEl
     * @param nextSibling
     * @returns Added element count
     */
    static insertNodesBefore(nodes: AnyDLNode[], parentEl: HTMLElement, nextSibling: HTMLElement): number;
    /**
     * @brief Append nodes to the parentEl
     * @param nodes
     * @param parentEl
     * @returns Added element count
     */
    static appendNodes(nodes: any[], parentEl: HTMLElement): number;
    private static willUnmountFunc;
    static addWillUnmount(node: AnyDLNode, func: () => void): void;
}

/**
 * @brief Plainly set style
 * @param el
 * @param value
 */
declare function setStyle(el: HTMLElement, value: CSSStyleDeclaration): void;
/**
 * @brief Plainly set dataset
 * @param el
 * @param value
 */
declare function setDataset(el: HTMLElement, value: Record<string, string>): void;
/**
 * @brief Set HTML property with checking value equality first
 * @param el
 * @param key
 * @param value
 */
declare function setHTMLProp(el: HTMLElement, key: keyof HTMLElement, value: any): void;
/**
 * @brief Plainly set HTML properties
 * @param el
 * @param value
 */
declare function setHTMLProps(el: HTMLElement, value: Record<string, any>): void;
/**
 * @brief Set HTML attribute with checking value equality first
 * @param el
 * @param key
 * @param value
 */
declare function setHTMLAttr(el: HTMLElement, key: string, value: any): void;
/**
 * @brief Plainly set HTML attributes
 * @param el
 * @param value
 */
declare function setHTMLAttrs(el: HTMLElement, value: Record<string, any>): void;
/**
 * @brief Set memorized event, store the previous event in el[`$on${key}`], if it exists, remove it first
 * @param el
 * @param key
 * @param value
 */
declare function setEvent(el: HTMLElement, key: string, value: any): void;
/**
 * @brief Create a template function, which returns a function that returns a cloned element
 * @param templateStr
 * @returns a function that returns a cloned element
 */
declare function createTemplate(templateStr: string): () => HTMLElement;
/**
 * @brief Shortcut for document.createElement
 * @param tag
 * @returns HTMLElement
 */
declare function createElement(tag: string): HTMLElement;
/**
 * @brief Insert any DLNode into an element, set the _$nodes and append the element to the element's children
 * @param el
 * @param node
 * @param position
 */
declare function insertNode(el: HTMLElement, node: AnyDLNode, position: number): void;
/**
 * @brief An inclusive assign prop function that accepts any type of prop
 * @param el
 * @param key
 * @param value
 */
declare function forwardHTMLProp(el: HTMLElement, key: string, value: any): void;

declare global {
    interface Window {
        DLEnvStore: EnvStoreClass;
    }
}
declare class EnvStoreClass {
    envs: Record<string, [any, AnyDLNode]>;
    currentEnvNodes: EnvNode[];
    /**
     * @brief Add a node to the current env and merge envs
     * @param node
     */
    addEnvNode(node: AnyDLNode): void;
    /**
     * @brief Replace the current env with the given nodes and merge envs
     * @param nodes
     */
    replaceEnvNodes(nodes: AnyDLNode[]): void;
    /**
     * @brief Remove the last node from the current env and merge envs
     */
    removeEnvNode(): void;
    /**
     * @brief Merge all the envs in currentEnvNodes, inner envs override outer envs
     */
    private mergeEnvs;
}
declare class EnvNode extends DLNode {
    updateNodes: Set<CompNode>;
    envs: Record<string, any>;
    /**
     * @brief Constructor, Env type, accept a record of envs, add this node to DLEnvStore
     * @param envs
     */
    constructor(envs: Record<string, any>);
    /**
     * @brief Update a specific env, and update all the comp nodes that depend on this env
     * @param name
     * @param value
     */
    updateEnv(name: string, value: any): void;
    /**
     * @brief Add a node to this.updateNodes, delete the node from this.updateNodes when it unmounts
     * @param node
     */
    addNode(node: AnyDLNode): void;
    /**
     * @brief Set this._$nodes, and exit the current env
     * @param nodes
     */
    initNodes(nodes: AnyDLNode[]): void;
}

declare class CompNode extends DLNode {
    /**
     * @brief Constructor, Comp type
     * @internal
     *  * key - getter: return $key
     *  * key - setter: set $key, update $s$key, call update function with $$key
     *  * $key - private property key
     *  * $$key - dependency number, e.g. 0b1, 0b10, 0b100
     *  * $s$key - set of properties that depend on this property
     *  * $p$key - exist if this property is a prop
     *  * $e$key - exist if this property is an env
     *  * $en$key - exist if this property is an env, and it's the innermost env that contains this env
     *  * $w$key - exist if this property is a watcher
     *  * $f$key - a function that returns the value of this property, called when the property's dependencies change
     *  * _$children - children nodes of type PropView
     *  * _$contentKey - the key key of the content prop
     *  * _$forwardProps - exist if this node is forwarding props
     *  * _$forwardPropsId - the keys of the props that this node is forwarding, collected in _$setForwardProp
     *  * _$forwardPropsSet - contain all the nodes that are forwarding props to this node, collected with _$addForwardProps
     */
    constructor();
    /**
     * @brief Init function, called explicitly in the subclass's constructor
     * @param props
     * @param content
     * @param children
     * @param forwardPropsScope
     */
    _$init(props: Record<string, any> | null, content: any | null, children: AnyDLNode[] | null, forwardPropsScope: CompNode | null): void;
    /**
     * @brief Call updates manually before the node is mounted
     */
    private _$callUpdatesBeforeInit;
    /**
     * @brief Define forward props
     * @param key
     * @param value
     */
    private _$setForwardProp;
    /**
     * @brief Add a node to the set of nodes that are forwarding props to this node and init these props, called
     *  1. HTMLNode: explicitly in the View function
     *  2. CompNode: passed in the node's constructor and called in _$init to make sure it's added before the node is mounted
     * @param node
     */
    _$addForwardProps(node: AnyDLNode): void;
    /**
     * @brief Set a prop directly, if this is a forwarded prop, go and init forwarded props
     * @param key
     * @param value
     */
    _$setProp(key: string, value: any): void;
    /**
     * @brief Init an env, put the corresponding innermost envNode in $en$key
     * @param key
     * @param value
     * @param envNode
     */
    private _$initEnv;
    /**
     * @brief Update an env, called in EnvNode._$update
     * @param key
     * @param value
     * @param envNode
     */
    _$updateEnv(key: string, value: any, envNode: EnvNode): void;
    /**
     * @brief Set the content prop, the key is stored in _$contentKey
     * @param value
     * @returns
     */
    _$setContent(value: any): void;
    /**
     * @brief Update a prop and call any related update function
     * @param key
     * @param value
     */
    _$updateProp(key: string, value: any): void;
    /**
     * @brief Update properties that depend on this property
     * @param key
     */
    _$updateDerived(key: string): void;
    /**
     * @brief Update View related update function
     * @param key
     */
    _$updateView(key: string): void;
}
declare const View: any;
/**
 * @brief Run all update functions given the key
 * @param dlNode
 * @param key
 */
declare function update(dlNode: AnyDLNode, key: string): void;

declare class MutableNode extends DLNode {
    /**
     * @brief Mutable node is a node that this._$nodes can be changed, things need to pay attention:
     *  1. The environment of the new nodes should be the same as the old nodes
     *  2. The new nodes should be added to the parentEl
     *  3. The old nodes should be removed from the parentEl
     * @param type
     */
    constructor(type: number);
    /**
     * @brief Initialize the new nodes, add parentEl to all nodes
     * @param nodes
     */
    private initNewNodes;
    /**
     * @brief Generate new nodes in the saved environment
     * @param newNodesFunc
     * @returns
     */
    geneNewNodesInEnv(newNodesFunc: () => AnyDLNode[]): AnyDLNode[];
    removeNodes(nodes: any[]): void;
}

declare class ForNode<T, G> extends MutableNode {
    array: T[];
    keys?: G[] | undefined;
    nodeFunc: (item: T) => AnyDLNode[];
    nodess: any[][];
    depNum: number;
    /**
     * @brief Constructor, For type
     * @param array
     * @param nodeFunc
     * @param keys
     */
    constructor(array: T[], nodeFunc: (item: T) => AnyDLNode[], depNum: number, keys?: G[]);
    /**
     * @brief Non-array update function
     * @param changed
     */
    update(changed: number): void;
    /**
     * @brief Update the view related to one item in the array
     * @param nodes
     * @param item
     */
    private updateItem;
    /**
     * @brief Array-related update function
     * @param newArray
     * @param newKeys
     */
    updateArray(newArray: T[], newKeys?: G[]): void;
    /**
     * @brief Shortcut to generate new nodes with idx
     */
    private getNewNodes;
    /**
     * @brief Update the nodes without keys
     * @param newArray
     */
    private updateWithOutKey;
    /**
     * @brief Update the nodes with keys
     * @param newArray
     * @param newKeys
     */
    private updateWithKey;
    /**
     * @brief Compare two arrays
     * @param arr1
     * @param arr2
     * @returns
     */
    private static arrayEqual;
}

declare class ExpNode extends MutableNode {
    nodesFunc: () => AnyDLNode[];
    /**
     * @brief Constructor, Exp type, accept a function that returns a list of nodes
     * @param nodesFunc
     */
    constructor(nodesFunc: () => AnyDLNode[]);
    /**
     * @brief Generate new nodes and replace the old nodes
     */
    update(): void;
    /**
     * @brief Format the nodes
     * @param nodes
     * @returns New nodes
     */
    private static formatNodes;
}

declare class CondNode extends MutableNode {
    condFunc: (thisCond: CondNode) => AnyDLNode[];
    cond: number;
    depNum: number;
    /**
     * @brief Constructor, If type, accept a function that returns a list of nodes
     * @param caseFunc
     */
    constructor(condFunc: (thisCond: CondNode) => AnyDLNode[], depNum: number);
    /**
     * @brief Update the nodes in the environment
     */
    updateCond(): void;
    /**
     * @brief Update the children of IfNode
     */
    updateChildren(changed?: number): void;
    /**
     * @brief The update function of IfNode's childNodes is stored in the first child node
     * @param changed
     */
    update(changed: number): void;
}

/**
 * @brief Shorten document.createTextNode
 * @param value
 * @returns Text
 */
declare function createTextNode(value: string): Text;
/**
 * @brief Update text node and check if the value is changed
 * @param node
 * @param value
 */
declare function updateText(node: Text, value: string): void;

declare class PropView {
    propViewFunc: () => AnyDLNode[];
    dlUpdateNodes: Set<any>;
    /**
     * @brief PropView constructor, accept a function that returns a list of DLNode
     * @param propViewFunc
     */
    constructor(propViewFunc: () => AnyDLNode[]);
    /**
     * @brief Build the prop view by calling the propViewFunc and add every single instance of the returned DLNode to dlUpdateNodes
     * @returns the list of DLNode returned by propViewFunc
     */
    build(): AnyDLNode[];
    /**
     * @brief Update every node in dlUpdateNodes
     * @param changed
     */
    update(changed: number): void;
}

declare function render(idOrEl: string | HTMLElement, DL: AnyDLNode): void;
declare function manual(callback: () => any, _deps?: any[]): any;
declare function escape<T>(arg: T): T;
declare const $: typeof escape;

export { $, CompNode, CondNode, EnvNode, ExpNode, ForNode, PropView, View, createElement, createTemplate, createTextNode, escape, forwardHTMLProp, insertNode, manual, render, setDataset, setEvent, setHTMLAttr, setHTMLAttrs, setHTMLProp, setHTMLProps, setStyle, update, updateText };

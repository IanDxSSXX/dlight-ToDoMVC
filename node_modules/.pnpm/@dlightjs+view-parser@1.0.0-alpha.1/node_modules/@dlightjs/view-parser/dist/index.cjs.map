{"version":3,"sources":["../src/index.ts","../src/error.ts","../src/parser.ts"],"sourcesContent":["import { ViewParser } from \"./parser\"\nimport {\n  type ViewUnit,\n  type ViewParserConfig,\n  type ViewParserOption,\n} from \"./types\"\nimport { type types as t } from \"@babel/core\"\n\n/**\n * @brief Generate view units from a babel ast\n * @param statement\n * @param config\n * @param options\n * @returns ViewUnit[]\n */\nexport function parseView(\n  statement: t.BlockStatement,\n  config: ViewParserConfig,\n  options?: ViewParserOption\n): ViewUnit[] {\n  return new ViewParser(config, options).parse(statement)\n}\n\nexport type * from \"./types\"\n","import { createErrorHandler } from \"@dlightjs/error-handler\"\n\nexport const DLError = createErrorHandler(\n  \"ViewParser\",\n  {\n    1: \"Invalid syntax in DLight's View, only accepts dot chain call expression\",\n    2: \"First argument of $0() must be an expression\",\n    3: \"Invalid syntax in DLight's View, only accepts expression as props\",\n    4: \"Invalid SubView calling, only accepts static subview calling like `this.SubView()`\",\n  },\n  {\n    1: \"DLight only accepts ForOfStatement as for loop, skipping this statement\",\n    2: \"EnvUnit must have at least one child, skipping this statement\",\n    3: \"Only Env/Comp/HTMLUnit can have a statement block as its children, skipping this statement\",\n    4: \"If you want to use a key in a for loop, make the first statement as a label statement like `key: item`, skipping this key for now\",\n    5: \"ForUnit must have at least one child, skipping this statement\",\n  },\n  {\n    1: \"EnvUnit must have at least one prop, skipping this statement and flattening its children\",\n  }\n)\n","import { type types as t, type traverse as tr } from \"@babel/core\"\nimport {\n  type ViewProp,\n  type IfBranch,\n  type ViewUnit,\n  type ViewParserConfig,\n  type ViewParserOption,\n  SwitchBranch,\n} from \"./types\"\nimport { DLError } from \"./error\"\n\nexport class ViewParser {\n  private readonly compWrapper: string = \"comp\"\n  private readonly htmlTagWrapper: string = \"tag\"\n  private readonly environmentTagName: string = \"env\"\n  private readonly expressionTagName: string = \"_\"\n\n  private readonly config: ViewParserConfig\n  private readonly options?: ViewParserOption\n\n  private readonly t: typeof t\n  private readonly traverse: typeof tr\n  private readonly subviewNames: string[]\n  private readonly htmlTags: string[]\n\n  readonly viewUnits: ViewUnit[] = []\n\n  /**\n   * @brief Constructor\n   * @param statement\n   * @param config\n   * @param options\n   */\n  constructor(config: ViewParserConfig, options?: ViewParserOption) {\n    this.config = config\n    this.options = options\n    this.t = config.babelApi.types\n    this.traverse = config.babelApi.traverse\n    this.subviewNames = config.subviewNames\n    this.htmlTags = config.htmlTags\n    options?.environmentTagName &&\n      (this.environmentTagName = options.environmentTagName)\n    options?.expressionTagName &&\n      (this.expressionTagName = options.expressionTagName)\n    options?.htmlTagWrapper && (this.htmlTagWrapper = options.htmlTagWrapper)\n    options?.compWrapper && (this.compWrapper = options.compWrapper)\n  }\n\n  parse(statement: t.BlockStatement) {\n    const statements = [...statement.directives, ...statement.body]\n    statements.forEach(this.parseStatement.bind(this))\n    // ---- If the view is an empty env, throw an error\n    if (\n      this.viewUnits.length === 1 &&\n      this.viewUnits[0].type === \"env\" &&\n      this.viewUnits[0].children.length === 0\n    ) {\n      DLError.error2()\n      return []\n    }\n\n    return this.viewUnits\n  }\n\n  /**\n   * @brief Parse the statements\n   * @returns\n   */\n  private parseStatement(statement: t.Statement | t.Directive): void {\n    if (this.isInvalidExpression(statement)) return\n    if (this.t.isExpressionStatement(statement)) {\n      this.parseExpression(statement.expression)\n      return\n    }\n    if (this.t.isForOfStatement(statement)) {\n      this.parseFor(statement)\n      return\n    }\n    if (this.t.isIfStatement(statement)) {\n      this.parseIf(statement)\n      return\n    }\n    if (this.t.isSwitchStatement(statement)) {\n      this.parseSwitch(statement)\n      return\n    }\n    if (this.t.isDirective(statement)) {\n      this.parseText(statement.value)\n      return\n    }\n    if (this.t.isBlockStatement(statement)) {\n      // ---- If the statement is a block statement, treat it as last unit's children\n      const lastViewUnit = this.viewUnits[this.viewUnits.length - 1]\n      const type = lastViewUnit?.type\n      const childViewUnits = this.parseView(statement)\n      if (type === \"html\") {\n        delete lastViewUnit.content\n        lastViewUnit.children = childViewUnits\n      } else if (type === \"comp\" || type === \"subview\") {\n        lastViewUnit.children = childViewUnits\n      } else if (type === \"env\") {\n        if (childViewUnits.length > 0) {\n          lastViewUnit.children = childViewUnits\n        } else {\n          this.viewUnits.pop()\n          DLError.error2()\n        }\n      } else {\n        DLError.error3()\n      }\n    }\n  }\n\n  /**\n   * @brief Parse the expression node\n   *  CallExpression -> Tag\n   *  StringLiteral/TemplateLiteral -> Text\n   *  TaggedTemplateExpression -> Tag + Text / Exp\n   * @param expression\n   */\n  private parseExpression(expression: t.Expression): void {\n    if (this.t.isCallExpression(expression)) {\n      this.parseTag(expression)\n      return\n    }\n    if (\n      this.t.isStringLiteral(expression) ||\n      this.t.isTemplateLiteral(expression)\n    ) {\n      this.parseText(expression)\n      return\n    }\n    if (this.t.isTaggedTemplateExpression(expression)) {\n      this.parseTaggedTemplate(expression)\n      return\n    }\n\n    // ---- Default ExpressionTag\n    //      e.g. this.count -> _(this.count)\n    this.viewUnits.push({\n      type: \"exp\",\n      content: this.parseProp(expression),\n    })\n  }\n\n  /**\n   * @brief Parse if statement conditions\n   * @param node\n   * @returns IfBranch[]\n   */\n  private parseIfBranches(node: t.IfStatement): IfBranch[] {\n    const conditions: IfBranch[] = []\n    const condition = node.test\n    const ifBody = this.t.isBlockStatement(node.consequent)\n      ? node.consequent\n      : this.t.blockStatement([node.consequent])\n    conditions.push({\n      condition,\n      children: this.parseView(ifBody),\n    })\n\n    // ---- If the alternate is an if statement, parse it recursively\n    if (this.t.isIfStatement(node.alternate)) {\n      conditions.push(...this.parseIfBranches(node.alternate))\n    } else if (node.alternate) {\n      const altBody = this.t.isBlockStatement(node.alternate)\n        ? node.alternate\n        : this.t.blockStatement([node.alternate])\n      conditions.push({\n        condition: this.t.booleanLiteral(true),\n        children: this.parseView(altBody),\n      })\n    }\n\n    return conditions\n  }\n\n  /**\n   * @brief Parse if statement with else if and else\n   * @param node\n   */\n  private parseIf(node: t.IfStatement): void {\n    this.viewUnits.push({\n      type: \"if\",\n      branches: this.parseIfBranches(node),\n    })\n  }\n\n  /**\n   * @brief Parse switch statement\n   * @param node\n   */\n  private parseSwitch(node: t.SwitchStatement) {\n    const branches: SwitchBranch[] = []\n    const switchBody = node.cases\n    switchBody.forEach(s => {\n      const caseBodyPre = s.consequent\n      const caseBody =\n        caseBodyPre.length === 1 && this.t.isBlockStatement(caseBodyPre[0])\n          ? caseBodyPre[0]\n          : this.t.blockStatement(caseBodyPre)\n      const isBreak = this.t.isBreakStatement(\n        caseBody.body[caseBody.body.length - 1]\n      )\n      if (isBreak) {\n        caseBody.body.pop()\n      }\n\n      const children = this.parseView(caseBody)\n      const branch: SwitchBranch = {\n        case: s.test,\n        children,\n        break: isBreak,\n      }\n      branches.push(branch)\n    })\n    this.viewUnits.push({\n      type: \"switch\",\n      discriminant: node.discriminant,\n      branches,\n    })\n  }\n\n  /**\n   * @brief Parse for of loop\n   * Only accept for of loop with variable declaration\n   *  e.g. for (const item of array) {}\n   * Key:\n   *  1. If the first statement is an array expression and is not a null or undefined,\n   *     treat the first element as the key.\n   *     e.g. for (const { idx, item } of array) { [idx]; div(item) }\n   *          key will be \"idx\"\n   *  2. If the first statement is an array expression and is null or undefined, treat it as a non-keyed loop.\n   *      e.g. for (const { item } of array) { [null]; div(item) }\n   *          no specific key\n   *  3. If the first statement is not an array expression, treat the item itself as the key.\n   *      e.g. for (const item of array) { div(item) }\n   *          key will be \"item\"\n   * @param node\n   */\n  private parseFor(node: t.ForOfStatement): void {\n    const left = node.left\n    if (!this.t.isVariableDeclaration(left)) {\n      DLError.throw1()\n    }\n    const item = (left as t.VariableDeclaration).declarations[0].id\n    const array = node.right\n    let key: t.Expression | undefined\n    const forBody = node.body\n    let forBodyStatements: Array<t.Statement | t.Directive>\n    if (this.t.isExpressionStatement(forBody)) {\n      // ---- If the for body is an expression statement, treat it as the only statement\n      forBodyStatements = [forBody]\n    } else if (this.t.isBlockStatement(forBody)) {\n      const childNodes = forBody.body\n      if (childNodes.length === 0) return DLError.error5()\n      const firstStatement = childNodes[0]\n      if (\n        this.t.isLabeledStatement(firstStatement) &&\n        this.t.isIdentifier(firstStatement.label)\n      ) {\n        if (\n          firstStatement.label.name !== \"key\" ||\n          !this.t.isExpressionStatement(firstStatement.body)\n        ) {\n          DLError.error4()\n        } else {\n          // ---- Treat the first array element labeled by key as the key\n          const keyNode = firstStatement.body.expression\n          // ---- If the key is undefined or null, treat it as no key\n          if (\n            this.t.isExpression(keyNode) &&\n            !(\n              this.t.isNullLiteral(keyNode) ||\n              (this.t.isIdentifier(keyNode) && keyNode.name === \"undefined\")\n            )\n          ) {\n            key = keyNode\n          }\n        }\n        forBodyStatements = childNodes.slice(1)\n      } else {\n        forBodyStatements = childNodes\n      }\n    } else return\n\n    const directives = forBodyStatements.filter(s =>\n      this.t.isDirective(s)\n    ) as t.Directive[]\n    const statements = forBodyStatements.filter(\n      s => !this.t.isDirective(s)\n    ) as t.Statement[]\n    const forBodyBlockStatement = this.t.blockStatement(statements, directives)\n    // ---- Parse the for body statements\n    this.viewUnits.push({\n      type: \"for\",\n      item,\n      array,\n      key,\n      children: this.parseView(forBodyBlockStatement),\n    })\n  }\n\n  /**\n   * @brief Parse text node\n   *  1. `text text`\n   *  2. \"text2 text2\"\n   * @param node\n   */\n  private parseText(\n    node: t.StringLiteral | t.TemplateLiteral | t.DirectiveLiteral\n  ): void {\n    if (this.t.isDirectiveLiteral(node)) node = this.t.stringLiteral(node.value)\n\n    this.viewUnits.push({\n      type: \"text\",\n      content: node,\n    })\n  }\n\n  /**\n   * @brief Parse tagged template expression\n   * Two tagged template expression cases\n   *  1. type without call expressions\n   *      e.g. i18n`any text`\n   *        => exp: _(i18n`any text`)\n   *  2. type with string literal / template literal\n   *      e.g. \"any text\" `any other text`/ `any text` `any other text`\n   *       => text: \"any text\" + text: `any other text`\n   * @param node\n   * @param path\n   */\n  private parseTaggedTemplate(node: t.TaggedTemplateExpression): void {\n    if (\n      this.t.isStringLiteral(node.tag) ||\n      this.t.isTemplateLiteral(node.tag)\n    ) {\n      // ---- Case 2\n      this.viewUnits.push({\n        type: \"text\",\n        content: node.tag,\n      })\n      this.viewUnits.push({\n        type: \"text\",\n        content: node.quasi,\n      })\n      return\n    }\n    // ---- Case 1\n    this.viewUnits.push({\n      type: \"exp\",\n      content: this.parseProp(node),\n    })\n  }\n\n  /**\n   * @brief Parse props in the type node\n   * @param propNode\n   * @returns ViewProp\n   */\n  private parseProp(propNode: t.Node | undefined): ViewProp {\n    if (propNode && !this.t.isExpression(propNode)) DLError.throw3()\n    propNode = propNode as t.Expression\n    // ---- If there is no propNode, set the default prop as true\n    if (!propNode) {\n      return {\n        value: this.t.booleanLiteral(true),\n        viewPropMap: {},\n      }\n    }\n\n    // ---- Collect View => {} nodes as DLProp\n    const dlViewPropResult: Record<string, ViewUnit[]> = {}\n    this.traverse(this.valueWrapper(propNode), {\n      ArrowFunctionExpression: innerPath => {\n        const node = innerPath.node\n        if (node.params.length === 0) return\n        const firstParam = node.params[0]\n        if (\n          !this.t.isIdentifier(firstParam, { name: \"View\" }) &&\n          !this.t.isIdentifier(firstParam, { name: \"_View\" })\n        )\n          return\n        const body = this.t.isBlockStatement(node.body)\n          ? node.body\n          : this.t.blockStatement([this.t.expressionStatement(node.body)])\n        const id = this.uid()\n        // ---- Parse the body of View => {} as a new View\n        dlViewPropResult[id] = this.parseView(body)\n        // ---- Replace the View => {} with a id string literal\n        const newNode = this.t.stringLiteral(id)\n        if (node === propNode) {\n          propNode = newNode\n        }\n        innerPath.replaceWith(newNode)\n        innerPath.skip()\n      },\n    })\n\n    return {\n      value: propNode,\n      viewPropMap: dlViewPropResult,\n    }\n  }\n\n  /**\n   * @brief Parse the type node\n   * @param node\n   */\n  private parseTag(node: t.CallExpression): void {\n    const props: Record<string, ViewProp> = {}\n\n    // ---- Keep iterating until the node has no call expression\n    let n = node\n    while (\n      this.t.isMemberExpression(n?.callee) &&\n      n?.callee?.object &&\n      !this.isPureMemberExpression(n.callee)\n    ) {\n      const property = n.callee.property\n      if (\n        !this.t.isIdentifier(property) ||\n        !this.t.isCallExpression(n.callee.object)\n      ) {\n        DLError.throw1()\n        continue\n      }\n\n      const key = property.name\n      const prop = this.parseProp(n.arguments[0])\n      props[key] = prop\n      n = n.callee.object\n    }\n\n    let contentProp: ViewProp | undefined\n    if (n.arguments.length > 0) {\n      // ---- The last argument is the content prop of the type,\n      //      so only parse prop when it exists instead of\n      //      treating empty prop as \"true\" like other props\n      contentProp = this.parseProp(n.arguments[0])\n    }\n\n    if (this.t.isIdentifier(n.callee)) {\n      // ---- Special cases for expression type\n      const tagName = n.callee.name\n      if (tagName === this.expressionTagName && contentProp) {\n        // ---- Must have content prop or else just ignore it\n        this.viewUnits.push({\n          type: \"exp\",\n          content: contentProp,\n          props,\n        })\n        return\n      }\n      if (tagName === this.environmentTagName) {\n        if (Object.keys(props).length === 0) {\n          DLError.warn1()\n          return\n        }\n        this.viewUnits.push({\n          type: \"env\",\n          props,\n          children: [],\n        })\n        return\n      }\n      if (this.htmlTags.includes(tagName)) {\n        this.viewUnits.push({\n          type: \"html\",\n          tag: this.t.stringLiteral(tagName),\n          content: contentProp,\n          props,\n        })\n        return\n      }\n      // ---- Custom tag\n      this.viewUnits.push({\n        type: \"comp\",\n        tag: n.callee,\n        content: contentProp,\n        props,\n      })\n      return\n    }\n    if (\n      this.t.isMemberExpression(n.callee) &&\n      this.t.isThisExpression(n.callee.object) &&\n      this.t.isIdentifier(n.callee.property) &&\n      this.subviewNames.includes(n.callee.property.name)\n    ) {\n      // ---- Subview\n      if (contentProp) props.content = contentProp\n      if (\n        !(\n          this.t.isMemberExpression(n.callee) &&\n          this.t.isThisExpression(n.callee.object) &&\n          this.t.isIdentifier(n.callee.property)\n        )\n      )\n        return DLError.throw4()\n      this.viewUnits.push({\n        type: \"subview\",\n        tag: n.callee.property.name,\n        props,\n      })\n      return\n    }\n    if (this.t.isExpression(n.callee)) {\n      // ---- 1. Custom tag\n      //      2. htmlTag(xxx)\n      //      3. tag(xxx)\n      const [tagType, tag] = this.alterTagType(n.callee)\n      this.viewUnits.push({\n        type: tagType,\n        tag,\n        content: contentProp,\n        props,\n      })\n    }\n  }\n\n  /* ---- Helper Functions ---- */\n  /**\n   * @brief Test if the node is a pure member expression without call expression\n   * @param node\n   */\n  private isPureMemberExpression(node: t.Expression): boolean {\n    let isPure = true\n    this.traverse(this.valueWrapper(node), {\n      CallExpression: () => {\n        isPure = false\n      },\n    })\n    return isPure\n  }\n\n  /**\n   * @brief Alter the tag type by checking the tag name\n   * @param viewUnit\n   * @returns [\"html\" | \"comp\", t.Expression]\n   */\n  private alterTagType(tag: t.Expression): [\"html\" | \"comp\", t.Expression] {\n    if (this.t.isCallExpression(tag) && this.t.isIdentifier(tag.callee)) {\n      const tagName = tag.callee.name\n      const tagType =\n        tagName === this.htmlTagWrapper\n          ? \"html\"\n          : tagName === this.compWrapper\n            ? \"comp\"\n            : undefined\n      if (tagType) {\n        const tagTarget = tag.arguments[0]\n        if (!this.t.isExpression(tagTarget)) DLError.throw2(tagName)\n        return [tagType, tagTarget as t.Expression]\n      }\n    }\n    return [\"comp\", tag]\n  }\n\n  /**\n   * @brief Test if the expression is invalid\n   *  1. For: only accept ForOfStatement\n   * @param node\n   * @returns is this expression invalid\n   */\n  private isInvalidExpression(node: t.Statement | t.Directive): boolean {\n    const isInvalidForStatement =\n      this.t.isForStatement(node) && !this.t.isForOfStatement(node)\n    if (isInvalidForStatement) {\n      DLError.error1()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * @brief Wrap the value in a file\n   * @param node\n   * @returns wrapped value\n   */\n  private valueWrapper(node: t.Expression): t.File {\n    return this.t.file(this.t.program([this.t.expressionStatement(node)]))\n  }\n\n  /**\n   * @brief Parse the view by duplicating current parser's classRootPath, statements and htmlTags\n   * @param statements\n   * @returns ViewUnit[]\n   */\n  private parseView(statement: t.BlockStatement): ViewUnit[] {\n    return new ViewParser(this.config, this.options).parse(statement)\n  }\n\n  /**\n   * @brief Generate a unique id\n   * @returns a unique id\n   */\n  private uid(): string {\n    return Math.random().toString(36).slice(2)\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","parseView","__toCommonJS","import_error_handler","DLError","ViewParser","config","options","statement","DLError","lastViewUnit","type","childViewUnits","expression","node","conditions","condition","ifBody","altBody","branches","caseBodyPre","caseBody","isBreak","children","branch","left","item","array","key","forBody","forBodyStatements","childNodes","firstStatement","keyNode","directives","s","statements","forBodyBlockStatement","propNode","dlViewPropResult","innerPath","firstParam","body","id","newNode","props","n","property","prop","contentProp","tagName","tagType","tag","isPure","tagTarget","parseView","statement","config","options","ViewParser"]}